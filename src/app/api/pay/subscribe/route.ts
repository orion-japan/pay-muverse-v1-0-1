export const runtime = "nodejs";

import { NextRequest, NextResponse } from "next/server";
import { google } from "googleapis";
import dayjs from "dayjs";
import Payjp from "payjp";
import { createClient } from "@supabase/supabase-js";
import { adminAuth } from "@/lib/firebase-admin";
import { PLAN_ID_MAP } from "@/lib/constants/planIdMap";

/* ========= ENV ========= */
function mustEnv(name: string) {
  const v = process.env[name];
  if (!v) throw new Error(`Missing environment variable: ${name}`);
  return v;
}

[
  "NEXT_PUBLIC_SUPABASE_URL",
  "SUPABASE_SERVICE_ROLE_KEY",
  "PAYJP_SECRET_KEY",
  "GOOGLE_SERVICE_ACCOUNT_BASE64",
  "GOOGLE_SHEET_ID",
].forEach(mustEnv);

/* ========= Clients ========= */
const sb = createClient(
  mustEnv("NEXT_PUBLIC_SUPABASE_URL"),
  mustEnv("SUPABASE_SERVICE_ROLE_KEY"),
  { auth: { persistSession: false } }
);
const payjp = Payjp(mustEnv("PAYJP_SECRET_KEY"));

/* ========= Helpers ========= */
const safe = (v: any) => (v === undefined || v === null ? "" : v);

function normalizePayjpError(err: any) {
  const norm: Record<string, any> = {
    message: err?.message ?? null,
    type: err?.type ?? null,
    code: err?.code ?? null,
    status: err?.status ?? err?.response?.status ?? null,
  };
  try {
    // payjp-node „ÅØ response.body „Å´ JSON ÊñáÂ≠óÂàó„ÇíÊåÅ„Å§„Åì„Å®„Åå„ÅÇ„Çã
    const raw = err?.response?.body;
    if (raw) {
      try {
        norm.body = typeof raw === "string" ? JSON.parse(raw) : raw;
      } catch {
        norm.body = String(raw);
      }
    }
  } catch {}
  return norm;
}

function isAlreadySubscribedPayload(p: any) {
  try {
    const code = p?.error?.code || p?.body?.error?.code || p?.code;
    const msg = (
      p?.error?.message ||
      p?.body?.error?.message ||
      p?.message ||
      p?.detail ||
      ""
    )
      .toString()
      .toLowerCase();
    return code === "already_subscribed" || msg.includes("already_subscribed");
  } catch {
    return false;
  }
}

/* ========= Handler ========= */
export async function POST(req: NextRequest) {
  const logTrail: string[] = [];
  const log = (s: string) => logTrail.push(s);

  try {
    /* ---------- 1) Firebase ID Token ---------- */
    const authHeader = req.headers.get("authorization") || "";
    const idToken = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : null;

    if (!idToken) {
      log("‚ùå missing Authorization: Bearer <idToken>");
      return NextResponse.json(
        { success: false, error: "missing_id_token", logTrail },
        { status: 401 }
      );
    }

    let decoded: any;
    try {
      decoded = await adminAuth.verifyIdToken(idToken, true);
    } catch (e) {
      log(`‚ùå invalid_id_token: ${String((e as any)?.message || e)}`);
      return NextResponse.json(
        { success: false, error: "invalid_id_token", logTrail },
        { status: 401 }
      );
    }

    const firebase_uid: string | null = decoded?.uid ?? null;
    const emailFromToken: string | null = decoded?.email ?? null;
    log(`‚úÖ token verified: uid=${firebase_uid}, email=${emailFromToken}`);

    /* ---------- 2) Body ---------- */
    const body = (await req.json().catch(() => ({}))) as any;
    const {
      plan_type,
      customer_id,
      charge_amount,
      sofia_credit,
      tdsr_id, // 3DS Âæå„ÅÆ 2ÂõûÁõÆ POSTÔºàÈ°ßÂÆ¢„Ç´„Éº„Éâ 3DS „ÅÆÂ†¥Âêà„Å™„Å©Ôºâ
      charge_id, // 3DS Âæå„ÅÆ 2ÂõûÁõÆ POSTÔºàCharge 3DS „ÅÆÂ†¥ÂêàÔºâ
      user_email,
      user_code: user_code_from_body,
      force_cancel_existing,
    } = body ?? {};

    log(`üì• payload: ${JSON.stringify(body)}`);

    const missing: string[] = [];
    if (!plan_type) missing.push("plan_type");
    if (!customer_id) missing.push("customer_id");
    if (!firebase_uid) missing.push("firebase_uid(token)");
    if (missing.length) {
      log(`‚ö† missing: ${missing.join(",")}`);
      return NextResponse.json(
        { success: false, error: "ÂøÖË¶Å„Å™„Éë„É©„É°„Éº„Çø„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô", missing, logTrail },
        { status: 400 }
      );
    }

    // „Éó„É©„É≥„Ç≠„Éº„ÇíÊ≠£Ë¶èÂåñ
    const planKey = String(plan_type).toLowerCase();
    const plan_price_id = PLAN_ID_MAP[planKey];
    if (!plan_price_id || typeof plan_price_id !== "string") {
      log(`‚ùå invalid plan_type: ${plan_type} (resolved key=${planKey})`);
      return NextResponse.json(
        { success: false, error: `ÁÑ°Âäπ„Å™„Éó„É©„É≥: ${plan_type}`, logTrail },
        { status: 400 }
      );
    }
    log(`üì¶ plan_id = ${plan_price_id}`);

    /* ---------- 3) Supabase „É¶„Éº„Ç∂„Éº ---------- */
    let { data: user, error: userErr } = await sb
      .from("users")
      .select("*")
      .eq("firebase_uid", firebase_uid!)
      .single();

    if ((!user || userErr) && emailFromToken) {
      const retry = await sb
        .from("users")
        .select("*")
        .eq("click_email", emailFromToken)
        .single();
      user = retry.data;
      userErr = retry.error;
      if (user && (!user.firebase_uid || user.firebase_uid !== firebase_uid)) {
        await sb.from("users").update({ firebase_uid }).eq("user_code", user.user_code);
        log("üîÅ uid synced to users.firebase_uid");
      }
    }

    if (userErr || !user) {
      log(`‚ùå Supabase user not found: ${userErr?.message || "no row"}`);
      return NextResponse.json(
        { success: false, error: "„É¶„Éº„Ç∂„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì", logTrail },
        { status: 404 }
      );
    }

    const user_code = user.user_code as string;
    const isAdmin = user.user_role === "admin";
    log(`‚úÖ user loaded: ${user_code} (admin=${isAdmin ? "yes" : "no"})`);

    /* ===========================================================
       A) finalize: 3DS ÂæåÔºàtdsr_id / charge_idÔºâ‚Üí „Çµ„Éñ„Çπ„ÇØ‰ΩúÊàê
       =========================================================== */
    if (tdsr_id || charge_id) {
      log(
        `üîÅ finalize after 3DS: tdsr_id=${tdsr_id ?? "-"}, charge_id=${charge_id ?? "-"}`
      );

      // Áä∂ÊÖãÁ¢∫Ë™çÔºà„É≠„Ç∞„ÅÆ„ÅøÔºâ
      try {
        if (charge_id) {
          const ch = await payjp.charges.retrieve(String(charge_id));
          log(
            `‚ÑπÔ∏è charge.status=${ch?.status}, three_d_secure_status=${
              (ch as any)?.three_d_secure_status ?? "n/a"
            }`
          );
        } else if (tdsr_id && (payjp as any).tdsRequests?.retrieve) {
          const tds = await (payjp as any).tdsRequests.retrieve(tdsr_id);
          log(`‚ÑπÔ∏è tds_request.status=${tds?.status ?? "n/a"}`);
        }
      } catch (e: any) {
        log(`‚ö† status check failed: ${e?.message || e}`);
      }

      // --- Êó¢Â≠ò„Çµ„Éñ„Çπ„ÇØ„ÇíÂøÖ„Åö„Ç≠„É£„É≥„Çª„É´ ---
      if (force_cancel_existing) {
        try {
          const existing = await payjp.subscriptions.list({
            customer: String(customer_id),
            limit: 100,
          } as any);
          const targets = (existing?.data ?? []).filter((s: any) =>
            ["active", "trial", "trialing", "paused"].includes(String(s?.status))
          );
          log(
            `ü™ì cancel targets: ${targets.map((s: any) => `${s.id}:${s.status}`).join(", ") || "(none)"}`
          );
          for (const s of targets) {
            try {
              await payjp.subscriptions.cancel(s.id, { at_period_end: false } as any);
              log(`‚úÖ canceled: ${s.id}`);
            } catch (e: any) {
              log(`‚ö† cancel failed (${s.id}): ${e?.message}`);
            }
          }
          // DB ÂÅ¥„ÇÇ„ÇØ„É™„Ç¢
          await sb
            .from("users")
            .update({
              payjp_subscription_id: null,
              last_payment_date: null,
              next_payment_date: null,
            })
            .eq("user_code", user_code);
          log("‚úÖ DB subscription fields cleared");
        } catch (e: any) {
          log(`‚ö† subscriptions.list failed: ${e?.message}`);
        }
      }

      // --- Êñ∞Ë¶è„Çµ„Éñ„Çπ„ÇØ‰ΩúÊàê ---
      let subscription: any = null;
      try {
        subscription = await payjp.subscriptions.create({
          customer: String(customer_id),
          plan: String(plan_price_id),
        } as any);
        log(`‚úÖ subscription created: ${subscription?.id}`);
      } catch (err: any) {
        const nerr = normalizePayjpError(err);
        log(`üî• PAY.JP error (subscriptions.create): ${JSON.stringify(nerr)}`);

        // Êó¢„Å´Âä†ÂÖ•Ê∏à„Åø„ÅØÊàêÂäüÁõ∏ÂΩìÔºöÊó¢Â≠ò„ÇíÊãæ„ÅÜ
        if (isAlreadySubscribedPayload(nerr)) {
          try {
            const listed = await payjp.subscriptions.list({
              customer: String(customer_id),
              limit: 100,
            } as any);
            subscription =
              (listed?.data ?? []).find(
                (s: any) => String(s?.plan) === String(plan_price_id)
              ) || (listed?.data ?? [])[0];
            if (subscription) {
              log(`‚ÑπÔ∏è use existing subscription: ${subscription.id}`);
            } else {
              log("üî¥ already_subscribed but no subscription found");
            }
          } catch (e: any) {
            log(`üî¥ list after already_subscribed failed: ${e?.message}`);
          }
        }

        if (!subscription?.id) {
          return NextResponse.json(
            {
              success: false,
              error: "„Çµ„Éñ„Çπ„ÇØÁôªÈå≤„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
              detail: nerr.message || "subscriptions.create error",
              payjp: nerr,
              logTrail,
            },
            { status: 500 }
          );
        }
      }

      // --- DB ÂèçÊò† ---
      const currentStart = Number(subscription?.current_period_start ?? 0);
      const currentEnd = Number(subscription?.current_period_end ?? 0);
      const last_payment_date =
        currentStart > 0
          ? dayjs.unix(currentStart).format("YYYY-MM-DD")
          : dayjs().format("YYYY-MM-DD");
      const next_payment_date =
        currentEnd > 0
          ? dayjs.unix(currentEnd).format("YYYY-MM-DD")
          : dayjs().add(1, "month").format("YYYY-MM-DD");
      const payment_date = dayjs().format("YYYY-MM-DD");
      const subscription_id = String(subscription.id);

      const updatePayload: Record<string, any> = {
        payjp_subscription_id: subscription_id,
        last_payment_date,
        next_payment_date,
      };
      if (!isAdmin) {
        updatePayload.sofia_credit =
          typeof sofia_credit === "number" ? sofia_credit : user.sofia_credit ?? 0;
        updatePayload.click_type = planKey;
        updatePayload.plan_status = planKey;
      }

      const { data: updated, error: upErr } = await sb
        .from("users")
        .update(updatePayload)
        .eq("user_code", user_code)
        .select("user_code")
        .maybeSingle();

      if (upErr || !updated) {
        log(`üî¥ DB update error: ${upErr?.message || "0 rows updated"}`);
        return NextResponse.json(
          { success: false, error: "„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥ÊÉÖÂ†±„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", logTrail },
          { status: 500 }
        );
      }
      log(`‚úÖ DB updated, subscription_id=${subscription_id}`);

      // --- Google Sheets ËøΩË®ò ---
      let sheets: any;
      try {
        const decoded = Buffer.from(
          mustEnv("GOOGLE_SERVICE_ACCOUNT_BASE64"),
          "base64"
        ).toString("utf-8");
        const credentials = JSON.parse(decoded);

        const auth = new google.auth.GoogleAuth({
          credentials,
          scopes: ["https://www.googleapis.com/auth/spreadsheets"],
        });
        const authClient = await auth.getClient();
        sheets = google.sheets({ version: "v4", auth: authClient as any });
      } catch (err: any) {
        log(`‚ùå GoogleAuth init failed: ${err?.message ?? err}`);
        return NextResponse.json(
          { success: false, error: "Google Ë™çË®ºÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", logTrail },
          { status: 500 }
        );
      }

      const row = [
        safe(user_code),
        safe(user_email || emailFromToken),
        safe(planKey),
        typeof charge_amount === "number" ? charge_amount : 0,
        typeof sofia_credit === "number" ? sofia_credit : 0,
        safe(customer_id),
        safe(last_payment_date),
        safe(next_payment_date),
        safe(user.card_registered),
        safe(payment_date),
        "WebÊ±∫Ê∏à",
        safe(subscription_id),
        safe(plan_price_id),
      ];

      log("üì§ Sheets append start");
      try {
        await sheets.spreadsheets.values.append({
          spreadsheetId: mustEnv("GOOGLE_SHEET_ID"),
          range: "Sheet1!A1",
          valueInputOption: "USER_ENTERED",
          insertDataOption: "INSERT_ROWS",
          requestBody: { values: [row] },
        });
        log("‚úÖ Sheets append succeeded");
        return NextResponse.json({ success: true, logTrail });
      } catch (sheetError: any) {
        log(`‚ùå Sheets write failed: ${sheetError?.message}`);
        if (sheetError?.response?.data) {
          log(`üìÑ Sheets resp: ${JSON.stringify(sheetError.response.data)}`);
        }
        return NextResponse.json(
          {
            success: false,
            error: "Google Sheets „Å∏„ÅÆÊõ∏„ÅçËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
            detail: sheetError?.message,
            logTrail,
          },
          { status: 500 }
        );
      }
    }

    /* ===========================================================
       B) first call: 3DS Ë¶ÅÂê¶„ÅÆ„Åü„ÇÅ„Å´‰∏é‰ø°‰ΩúÊàê ‚Üí 3DS Ê°àÂÜÖ
       =========================================================== */
    const probeAmount =
      typeof charge_amount === "number" && charge_amount > 0 ? charge_amount : 100;
    log(`üí≥ create probe charge: amount=${probeAmount}`);

    let charge: any;
    try {
      charge = await payjp.charges.create({
        amount: probeAmount,
        currency: "jpy",
        customer: String(customer_id),
        capture: false,
        three_d_secure: true, // 3DS „ÇíË¶ÅÊ±Ç
        description: `3DS probe for ${planKey} by ${user_code_from_body || "unknown"}`,
      });
      log(`‚úÖ charge created: ${charge?.id}`);
    } catch (err: any) {
      const nerr = normalizePayjpError(err);
      log(`üî• PAY.JP error (charges.create): ${JSON.stringify(nerr)}`);
      return NextResponse.json(
        {
          success: false,
          error: "‰∏é‰ø°„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
          detail: "PAY.JP charges.create „Åß„Ç®„É©„Éº",
          payjp: nerr,
          logTrail,
        },
        { status: 500 }
      );
    }

    // SDK iframe „Åß„ÅØ charge_id „ÇíÊ∏°„Åõ„Å∞Ëµ∑Âãï„Åß„Åç„Çã„Åå„ÄÅÂæåÊñπ‰∫íÊèõ„ÅÆ„Åü„ÇÅ tds_request „ÇÇÁîüÊàêË©¶Ë°å
    let tdsr_id_created: string | null = null;
    try {
      if ((payjp as any).tdsRequests?.create) {
        const tdsReq = await (payjp as any).tdsRequests.create({ charge: charge.id });
        if (tdsReq?.id) {
          tdsr_id_created = tdsReq.id as string;
          log(`‚úÖ tds_request created: ${tdsr_id_created}`);
        } else {
          log("‚ö† tdsRequests.create returned no id");
        }
      }
    } catch (e: any) {
      log(`‚ö† tdsRequests.create failed: ${e?.message || e}`);
    }

    const confirmation_url = `https://pay.jp/tds/start?resource=charge&id=${charge.id}`;
    return NextResponse.json({
      success: false,
      confirmation_required: true,
      confirmation_url,
      tdsr_id: tdsr_id_created,
      charge_id: charge.id,
      logTrail,
    });
  } catch (error: any) {
    const msg = error?.message ?? String(error);
    log(`‚õî unhandled: ${msg}`);
    try {
      if (error?.response?.data) log(`üìÑ resp: ${JSON.stringify(error.response.data)}`);
    } catch {}
    return NextResponse.json(
      {
        success: false,
        error: "ÂÜÖÈÉ®„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü",
        detail: msg,
        logTrail,
      },
      { status: 500 }
    );
  }
}
