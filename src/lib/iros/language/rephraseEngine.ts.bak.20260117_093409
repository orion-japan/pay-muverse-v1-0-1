/* eslint-disable @typescript-eslint/no-explicit-any */

// src/lib/iros/language/rephraseEngine.ts
// iros â€” Rephrase/Generate Engine (slot-preserving)
//
// ç›®çš„ï¼š
// - LLMã¯ã€Œæ–‡ç« æ•´å½¢/è¡¨ç¾ã€ã ã‘ï¼ˆåˆ¤æ–­ã¯ã—ãªã„ï¼‰
// - slot key ã‚’è½ã¨ã•ãšã« â€œé€ã‚Œã‚‹å®Œæˆæ–‡â€ ã‚’ç”Ÿæˆã™ã‚‹ï¼ˆslot-preservingï¼‰
// - éœ²å‡ºç¦æ­¢ï¼ˆå†…éƒ¨ãƒ‘ãƒƒã‚¯/ãƒ¡ã‚¿/JSON/ã‚­ãƒ¼å/åˆ¶å¾¡ãƒãƒ¼ã‚«ãƒ¼ï¼‰ã‚’ç¢ºå®Ÿã«é®æ–­
// - ç›´è¿‘2å¾€å¾©ï¼ˆæœ€å¤§4ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼‰ã ã‘ã‚’ LLM ã«æ¸¡ã™ï¼ˆè–„ã¾ã‚Šé˜²æ­¢ï¼‰
//
// å®Ÿè£…æ–¹é‡ï¼š
// - debug.traceId ã¯ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§å¿…ãšç¢ºå®šã—ã€ãƒ­ã‚°/LLMå‘¼ã³å‡ºã—ã§çµ±ä¸€
// - [[ILINE]]...[[/ILINE]] ã¯æ”¹å¤‰ç¦æ­¢ï¼ˆæ¼ã‚ŒãŸã‚‰ç ´æ£„ï¼‰
// - recall-guardï¼ˆmust includeï¼‰ãŒã‚ã‚‹å ´åˆã€è½ã¡ãŸã‚‰ç ´æ£„ï¼ˆok=falseï¼‰
// - FlagshipGuard ã¯æ¡ç”¨ã‚²ãƒ¼ãƒˆï¼ˆFATALãªã‚‰1å›ã ã‘å†ç”Ÿæˆã€ãƒ€ãƒ¡ãªã‚‰æœ€å°fallbackæ¡ç”¨ï¼‰
//
// âœ… ONE_POINT scaffoldï¼ˆä»®ç½®ãä¸€ç‚¹ç¢ºå®šï¼‰
// - scaffoldç™ºç«ä¸­ã¯ã€Œä»®ç½®ãä¸€ç‚¹ã€ã‚’æœ¬æ–‡ã«å¿…ãšæ®‹ã™ï¼ˆå¾©å…ƒâ†’ä¸å¯èƒ½ãªã‚‰ä¸æ¡ç”¨ï¼‰
// - scaffold must-haveï¼ˆpurpose / è¦³æ¸¬è»¸ï¼‰ã¯ã€Œå¾©å…ƒâ†’ãƒ€ãƒ¡ãªã‚‰ seedFromSlotsã¸æˆ»ã™ã€
// - åˆ¤å®šé–¢æ•°ã¨å¾©å…ƒé–¢æ•°ã¯æ··ãœãªã„ï¼ˆè²¬å‹™åˆ†é›¢ï¼‰

import crypto from 'node:crypto';
import { chatComplete } from '../../llm/chatComplete';

import { recallGuardOk, shouldEnforceRecallGuard } from './rephrase/guards';
import { containsForbiddenLeakText, extractDirectTask } from './rephrase/leak';
import {
  extractLockedILines,
  verifyLockedILinesPreserved,
  buildLockRuleText,
} from './rephrase/ilineLock';
import { finalizeLamp } from './rephrase/lamp';
import {
  extractHistoryTextFromContext,
  extractLastTurnsFromContext,
} from './rephrase/history';

import { flagshipGuard } from '../quality/flagshipGuard';
import type { FlagshipVerdict } from '../quality/flagshipGuard';

// ---------------------------------------------
// types
// ---------------------------------------------
export type Slot = { key: string; text: string };

export type ExtractedSlots =
  | {
      slots: Slot[];
      keys: string[];
      source: string;
    }
  | null;

export type RephraseOptions = {
  model: string;
  temperature?: number;
  maxLinesHint?: number;

  /** ç›´å‰ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ï¼ˆæ¨å¥¨ï¼‰ */
  userText?: string | null;

  /**
   * 3è»¸ãƒ¡ã‚¿/çŠ¶æ…‹ãªã©ï¼ˆunknown ã§å—ã‘ã‚‹ï¼‰
   * - LLMã«ã¯è¦‹ã›ã‚‹ãŒã€æœ¬æ–‡ã«éœ²å‡ºã•ã›ãªã„ï¼ˆsystemã§æŠ‘åˆ¶ï¼‰
   */
  userContext?: unknown | null;

  /** âœ… ãƒ­ã‚°ç”¨ï¼ˆchatComplete ã® trace ã«æ¸¡ã™ï¼‰ */
  debug?: {
    traceId?: string | null;
    conversationId?: string | null;
    userCode?: string | null;
    renderEngine?: boolean | null;

    // âœ… äº’æ›/æ‹¡å¼µï¼šã“ã“ã«ä½•ãŒæ¥ã¦ã‚‚æ¨ã¦ãªã„ï¼ˆrecall-check ç­‰ãŒä½¿ã†ï¼‰
    [k: string]: any;
  } | null;
};

export type DebugFinal = {
  traceId: string;
  conversationId?: string | null;
  userCode?: string | null;
  renderEngine?: boolean | null;

  // âœ… äº’æ›/æ‹¡å¼µï¼šè¿½åŠ ã‚­ãƒ¼ä¿æŒ
  [k: string]: any;
};

export type RephraseResult =
  | {
      ok: true;
      slots: Slot[];
      meta: {
        inKeys: string[];
        outKeys: string[];
        rawLen: number;
        rawHead: string;
        note?: string;
        extra?: any;
      };
    }
  | {
      ok: false;
      reason: string;
      meta: {
        inKeys: string[];
        rawLen: number;
        rawHead: string;
      };
    };

// ---------------------------------------------
// basics
// ---------------------------------------------
function norm(s: unknown) {
  return String(s ?? '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim();
}

function normLiteForLog(s: any): string {
  return String(s ?? '')
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .replace(/[\u200B-\u200D\uFEFF]/g, '')
    .trim();
}

function safeHead(s: string, n = 80) {
  const t = String(s ?? '');
  return t.length <= n ? t : t.slice(0, n);
}

function clampLines(text: string, maxLines: number): string {
  const t = norm(text);
  if (!t) return '';
  const lines = t
    .split('\n')
    .map((x) => x.trim())
    .filter(Boolean);
  if (lines.length <= maxLines) return lines.join('\n');
  return lines.slice(0, Math.max(1, maxLines)).join('\n');
}

function clampChars(text: string, maxChars: number): string {
  const t = norm(text);
  if (!t) return '';
  if (t.length <= maxChars) return t;
  return t.slice(0, Math.max(0, maxChars - 1)) + 'â€¦';
}

function envFlagEnabled(raw: unknown, defaultEnabled: boolean) {
  const v = String(raw ?? '').trim().toLowerCase();
  if (!v) return defaultEnabled;
  if (['0', 'false', 'off', 'no', 'disabled'].includes(v)) return false;
  if (['1', 'true', 'on', 'yes', 'enabled'].includes(v)) return true;
  return defaultEnabled;
}

function tryGet(obj: any, path: string[]): any {
  let cur = obj;
  for (const k of path) {
    if (!cur || typeof cur !== 'object') return undefined;
    cur = cur[k];
  }
  return cur;
}

function safeContextToText(v: unknown): string {
  if (v == null) return '';
  if (typeof v === 'string') return clampChars(norm(v), 1800);
  try {
    return clampChars(JSON.stringify(v), 1800);
  } catch {
    return clampChars(norm(String(v)), 1800);
  }
}

function ensureDebugFinal(debug?: RephraseOptions['debug'] | null): DebugFinal {
  const base =
    debug && typeof debug === 'object'
      ? { ...(debug as Record<string, any>) }
      : ({} as Record<string, any>);

  const traceIdRaw = String(base.traceId ?? '').trim();
  const traceId = traceIdRaw || crypto.randomUUID(); // âœ… ã“ã“ã§å¿…ãšç¢ºå®š

  return {
    ...base, // âœ… è¿½åŠ ã‚­ãƒ¼ã‚’æ¨ã¦ãªã„
    traceId,
    conversationId: base.conversationId ?? null,
    userCode: base.userCode ?? null,
    renderEngine: base.renderEngine ?? true,
  };
}

// ---------------------------------------------
// slot extraction (slot-preserving)
// ---------------------------------------------
function stableOrderKeys(keys: string[]) {
  const ORDER = [
    'OBS',
    'SHIFT',
    'NEXT',
    'SAFE',
    'INSIGHT',
    // legacy-ish
    'opener',
    'facts',
    'mirror',
    'elevate',
    'move',
    'ask',
    'core',
    'add',
  ];
  return [...keys].sort((a, b) => {
    const ia = ORDER.indexOf(a);
    const ib = ORDER.indexOf(b);
    if (ia === -1 && ib === -1) return a.localeCompare(b);
    if (ia === -1) return 1;
    if (ib === -1) return -1;
    return ia - ib;
  });
}

/**
 * extractSlotBlocks() ã¨åŒç­‰ãƒ¬ãƒ³ã‚¸ã‹ã‚‰ã€Œkeyä»˜ã slotsã€ã‚’æŠ½å‡ºã™ã‚‹ã€‚
 * âœ… slotsãŒç„¡ã„å ´åˆã§ã‚‚ã€content/assistantText ã‹ã‚‰ç–‘ä¼¼slot(OBS)ã‚’ä½œã‚‹
 */
export function extractSlotsForRephrase(extra: any): ExtractedSlots {
  const framePlan =
    extra?.framePlan ??
    extra?.meta?.framePlan ??
    extra?.extra?.framePlan ??
    extra?.orch?.framePlan ??
    null;

  const slotsRaw =
    framePlan?.slots ??
    framePlan?.slotPlan?.slots ??
    extra?.slotPlan?.slots ??
    extra?.meta?.slotPlan?.slots ??
    null;

  // âœ… slotsãŒç„¡ã„ã‚±ãƒ¼ã‚¹ï¼ˆmicroGenerateç­‰ï¼‰ã‚’æ•‘ã†ï¼šcontentã‹ã‚‰ç–‘ä¼¼slotã‚’ä½œã‚‹
  if (!slotsRaw) {
    const fallbackText = norm(
      extra?.assistantText ??
        extra?.content ??
        extra?.meta?.assistantText ??
        extra?.meta?.content ??
        extra?.text ??
        extra?.meta?.text ??
        '',
    );

    if (!fallbackText) return null;

    return {
      slots: [{ key: 'OBS', text: fallbackText }],
      keys: ['OBS'],
      source: 'fallback:content',
    };
  }

  const out: Slot[] = [];

  if (Array.isArray(slotsRaw)) {
    for (const s of slotsRaw) {
      const key = String(s?.key ?? s?.id ?? s?.slotId ?? s?.name ?? '').trim();
      const text = norm(s?.text ?? s?.value ?? s?.content ?? s?.message ?? s?.out ?? '');
      if (!key || !text) continue;
      out.push({ key, text });
    }
  } else if (typeof slotsRaw === 'object' && slotsRaw) {
    const keys = stableOrderKeys(Object.keys(slotsRaw));
    for (const k of keys) {
      const v = (slotsRaw as any)[k];
      const text = norm(
        typeof v === 'string'
          ? v
          : v?.text ?? v?.content ?? v?.value ?? v?.message ?? v?.out ?? '',
      );
      if (!text) continue;
      out.push({ key: String(k), text });
    }
  }

  if (out.length === 0) return null;

  return {
    slots: out,
    keys: out.map((x) => x.key),
    source: 'framePlan.slots',
  };
}

// ---------------------------------------------
// FIXED fallback (for FIXED mode)
// ---------------------------------------------
function buildFixedBoxTexts(slotCount: number): string[] {
  const ZWSP = '\u200b';
  const full = [
    'ã¾ãšæ•´ç†ã®ç®±ã‚’3ã¤ã ã‘ç½®ãã€‚',
    'äº‹å®Ÿï¼šä½•ãŒèµ·ããŸï¼ˆèª°ï¼ã©ã“ï¼ã„ã¤ï¼‰',
    'æ„Ÿæƒ…ï¼šã„ã¾ä¸€ç•ªãã¤ã„åå¿œ',
    'æœ›ã¿ï¼šæœ¬å½“ã¯ã©ã†ãªã£ã¦ã»ã—ã„ï¼ˆçŸ­æ–‡ã§OKã€‚ã†ã¾ãæ›¸ã‹ãªãã¦ã„ã„ã€‚ï¼‰',
    'ã“ã“ã§æ­¢ã‚ã‚‹ã€‚',
  ].join('\n');

  if (slotCount <= 0) return [];
  if (slotCount === 1) return [full];

  const out = [full];
  while (out.length < slotCount) out.push(ZWSP);
  return out;
}

/**
 * âœ… â€œæœ¬æ–‡ã‚’å…ˆé ­ã‚¹ãƒ­ãƒƒãƒˆ1å€‹ã«æ½°ã™â€ã®ã‚’ã‚„ã‚ã‚‹
 * - ç©ºè¡ŒåŒºåˆ‡ã‚Šã‚’ã€Œæ®µè½ãƒ–ãƒ­ãƒƒã‚¯ã€ã¨ã—ã¦ keys ã«é †ç•ªã«å‰²ã‚Šå½“ã¦ã‚‹
 * - ä½™ã£ãŸãƒ–ãƒ­ãƒƒã‚¯ã¯ã€Œæœ€å¾Œã®ã‚­ãƒ¼ã€ã«é€£çµã—ã¦è½ã¨ã•ãªã„
 * - ä½™ã£ãŸã‚­ãƒ¼ã¯ ZWSP ã§åŸ‹ã‚ã‚‹
 */
function buildSlotsWithFirstText(inKeys: string[], firstText: string): Slot[] {
  const ZWSP = '\u200b';
  if (inKeys.length === 0) return [];

  const full = norm(firstText);

  if (!full) {
    return [
      { key: inKeys[0], text: '' },
      ...inKeys.slice(1).map((k) => ({ key: k, text: ZWSP })),
    ];
  }

  // 2è¡Œä»¥ä¸Šã®ç©ºè¡Œã§æ®µè½åˆ†å‰²ï¼ˆ1æ”¹è¡Œã¯æ–‡ä¸­æ”¹è¡Œã¨ã—ã¦æ®‹ã™ï¼‰
  const blocks = full
    .split(/\n\s*\n+/)
    .map((b) => norm(b))
    .filter(Boolean);

  // ãƒ–ãƒ­ãƒƒã‚¯ãŒ1ã¤ãªã‚‰å¾“æ¥äº’æ›ï¼ˆå…ˆé ­ã«å…¨é›†ç´„ï¼‰
  if (blocks.length <= 1) {
    const out: Slot[] = [{ key: inKeys[0], text: full }];
    for (let i = 1; i < inKeys.length; i++) out.push({ key: inKeys[i], text: ZWSP });
    return out;
  }

  const out: Slot[] = [];
  const takeN = Math.min(inKeys.length, blocks.length);

  for (let i = 0; i < takeN; i++) out.push({ key: inKeys[i], text: blocks[i] });

  // blocks ãŒä½™ã£ãŸã‚‰æœ€å¾Œã«é€£çµã—ã¦è½ã¨ã•ãªã„
  if (blocks.length > inKeys.length && inKeys.length > 0) {
    const rest = blocks.slice(inKeys.length).join('\n\n');
    const lastIdx = inKeys.length - 1;
    out[lastIdx] = {
      key: inKeys[lastIdx],
      text: norm((out[lastIdx]?.text ?? '') + '\n\n' + rest),
    };
  }

  // keys ãŒä½™ã£ãŸã‚‰ZWSPã§åŸ‹ã‚ã‚‹
  for (let i = takeN; i < inKeys.length; i++) out.push({ key: inKeys[i], text: ZWSP });

  return out;
}

// ---------------------------------------------
// recall-must-includeï¼ˆ@RESTORE.last / @Q.askï¼‰æŠ½å‡º
// ---------------------------------------------
function extractRecallMustIncludeFromSeed(seedDraftRaw: string): {
  restoreNeedle: string | null;
  questionNeedle: string | null;
} {
  const t = String(seedDraftRaw ?? '');

  let restoreNeedle: string | null = null;
  {
    const m =
      t.match(/@RESTORE[\s\S]*?"last"\s*:\s*"([^"]+)"/) ||
      t.match(/@RESTORE[\s\S]*?last"\s*:\s*"([^"]+)"/);
    if (m?.[1]) restoreNeedle = String(m[1]).trim();
  }

  let questionNeedle: string | null = null;
  {
    const m =
      t.match(/@Q[\s\S]*?"ask"\s*:\s*"([^"]+)"/) ||
      t.match(/@Q[\s\S]*?ask"\s*:\s*"([^"]+)"/);
    if (m?.[1]) questionNeedle = String(m[1]).trim();
  }

  return { restoreNeedle, questionNeedle };
}

function buildMustIncludeRuleText(args: {
  restoreNeedle: string | null;
  questionNeedle: string | null;
}): string {
  const a = args.restoreNeedle
    ? `- æ¬¡ã®æ–‡ã‚’æœ¬æ–‡ã«**ä¸€å­—ä¸€å¥ãã®ã¾ã¾**å«ã‚ã‚‹ï¼š\n  ${args.restoreNeedle}`
    : '';
  const b = args.questionNeedle
    ? `- æ¬¡ã®å•ã„ï¼ˆæ–‡ï¼‰ã‚’æœ¬æ–‡ã«**ä¸€å­—ä¸€å¥ãã®ã¾ã¾**å«ã‚ã‚‹ï¼š\n  ${args.questionNeedle}`
    : '';
  const body = [a, b].filter(Boolean).join('\n');

  if (!body) return '';
  return [
    '',
    'ã€æ”¹å¤‰ç¦æ­¢ï¼ˆrecall-must-includeï¼‰ã€‘',
    'ä»¥ä¸‹ã¯â€œå¾©å…ƒã®è¶³å ´â€ãªã®ã§ã€å‰Šé™¤ãƒ»è¨€ã„æ›ãˆãƒ»è¦ç´„ã¯ç¦æ­¢ã€‚',
    body,
    '',
  ].join('\n');
}

// ---------------------------------------------
// âœ… ONE_POINT scaffold helpersï¼ˆãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«çµ±åˆç‰ˆï¼‰
// ---------------------------------------------
type SlotLike = { key?: string; text?: string; content?: string; value?: string };

const SCAFFOLD_PREFACE = 'ã„ã¾ã®è¶³å ´ã¨ã—ã¦ä¸€ã¤ã ã‘ç½®ãã€‚é•ã£ãŸã‚‰æ¨ã¦ã¦ã„ã„ã€‚';
const SCAFFOLD_PURPOSE = 'ã“ã®æ–‡ç« ã¯â€œç­”ãˆã‚’æ¸¡ã™â€ãŸã‚ã˜ã‚ƒãªãã€ã‚ãªãŸãŒç­”ãˆã‚’å‡ºã™ãŸã‚ã®è¶³å ´ã‚’ç½®ãã€‚';

function normLite(s: unknown): string {
  return String(s ?? '')
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .replace(/[\u200B-\u200D\uFEFF]/g, '')
    .trim();
}

function getSlotText(s: SlotLike): string | null {
  const v = normLite(s.text ?? s.content ?? s.value ?? '');
  return v ? v : null;
}

function isScaffoldActive(slotsForGuard: SlotLike[] | null): boolean {
  const slots = Array.isArray(slotsForGuard) ? slotsForGuard : [];
  if (slots.length === 0) return false;

  const texts = slots
    .map((s) => getSlotText(s))
    .filter((x): x is string => Boolean(x));

  const hasPreface = texts.some((x) => x.includes(SCAFFOLD_PREFACE));
  const hasPurpose = texts.some((x) => x.includes(SCAFFOLD_PURPOSE));

  // ä¸¡æ–¹ãã‚ã£ã¦ã„ã‚‹ã¨ãã ã‘ scaffold æ‰±ã„
  return hasPreface && hasPurpose;
}

function shouldEnforceOnePointGuard(slotKeys: string[] | null | undefined): boolean {
  if (!Array.isArray(slotKeys) || slotKeys.length === 0) return false;

  // å°†æ¥: ONE_POINT ã‚­ãƒ¼ãŒæ¥ãŸã‚‰å³ scaffold æ‰±ã„
  if (slotKeys.some((k) => /ONE_POINT/i.test(String(k)))) return true;

  // ç¾çŠ¶: flagReply ãŒ ONE_POINT ã‚’å°‚ç”¨ã‚«ãƒ†ã‚´ãƒªã§å‡ºã™ï¼ˆFLAG_ONE_POINT_1 ç­‰ï¼‰
  if (slotKeys.some((k) => /^FLAG_ONE_POINT_/i.test(String(k)))) return true;

  return false;
}

function pickOnePointNeedle(
  slotsForGuard: SlotLike[] | null,
): { onePoint: string | null; source: string | null } {
  const slots = Array.isArray(slotsForGuard) ? slotsForGuard : [];
  if (slots.length === 0) return { onePoint: null, source: null };

  // (1) ONE_POINT key ãŒã‚ã‚‹ãªã‚‰ãã‚Œã‚’å„ªå…ˆï¼ˆå°†æ¥ç”¨ï¼‰
  for (const s of slots) {
    const k = String(s?.key ?? '').trim();
    if (!k) continue;
    if (/ONE_POINT/i.test(k)) {
      const t = getSlotText(s);
      if (t) return { onePoint: t, source: k };
    }
  }

  // (2) ã„ã¾ã®å®Ÿè£…æƒ³å®šï¼šFLAG_DYNAMICS_1 ã‚’ä¸€ç‚¹ã¨ã—ã¦æ‰±ã†
  for (const s of slots) {
    const k = String(s?.key ?? '').trim();
    if (k === 'FLAG_DYNAMICS_1') {
      const t = getSlotText(s);
      if (t) return { onePoint: t, source: k };
    }
  }

  // (ä¿é™º) FLAG_DYNAMICS_* ã®æœ€åˆãŒã‚ã‚Œã°æ‹¾ã†
  const dyn = slots
    .map((s) => ({
      k: String(s?.key ?? '').trim(),
      t: getSlotText(s),
    }))
    .filter((x) => x.k.startsWith('FLAG_DYNAMICS_') && x.t);

  if (dyn.length > 0) return { onePoint: dyn[0]!.t!, source: dyn[0]!.k };

  return { onePoint: null, source: null };
}

/**
 * âœ… ONE_POINT ã‚’æœ¬æ–‡ã«æ®‹ã™ï¼ˆå¾©å…ƒå‰æï¼‰
 * - scaffoldActive ã§ã®ã¿å¼·åˆ¶
 * - slotså´ã«ä¸€ç‚¹ãŒç„¡ã„å ´åˆã¯ FATAL
 */
function ensureOnePointInOutput(args: {
  slotsForGuard: SlotLike[] | null;
  llmOut: string;
}): { ok: boolean; out: string; missing: string[]; needles: { onePoint: string | null; source: string | null } } {
  const out0 = String(args.llmOut ?? '');
  const out = normLite(out0);
  if (!out) {
    return { ok: false, out: out0, missing: ['OUT_EMPTY'], needles: { onePoint: null, source: null } };
  }

  if (!isScaffoldActive(args.slotsForGuard)) {
    return { ok: true, out: out0, missing: [], needles: { onePoint: null, source: null } };
  }

  const picked = pickOnePointNeedle(args.slotsForGuard);

  if (!picked.onePoint) {
    return {
      ok: false,
      out: out0,
      missing: ['ONE_POINT_MISSING_IN_SLOTS'],
      needles: { onePoint: null, source: picked.source },
    };
  }

  // ã™ã§ã«â€œä¸€å­—ä¸€å¥â€å…¥ã£ã¦ã‚‹ãªã‚‰OK
  if (out.includes(normLite(picked.onePoint))) {
    return { ok: true, out: out0, missing: [], needles: picked };
  }

  // ãªã„ãªã‚‰å¾©å…ƒ
  const restored = restoreOnePointInOutput({ llmOut: out0, onePoint: picked.onePoint });

  // å¾©å…ƒå¾Œã‚‚å…¥ã‚‰ãªã„ãªã‚‰ reject
  if (!normLite(restored).includes(normLite(picked.onePoint))) {
    return {
      ok: false,
      out: restored,
      missing: ['ONE_POINT_NOT_PRESERVED'],
      needles: picked,
    };
  }

  return { ok: true, out: restored, missing: [], needles: picked };
}

/**
 * âœ… ONE_POINT å·®ã—æˆ»ã—ï¼ˆscaffoldãŒã‚ã‚‹ã‚¿ãƒ¼ãƒ³ã ã‘ï¼‰
 * - â€œã„ã¾ã®ä¸€ç‚¹ï¼šâ€ è¡Œã‚’å„ªå…ˆå›ºå®š
 * - ãªã‘ã‚Œã° purpose ç›´å¾Œ
 * - æœ€å¾Œã¯å…ˆé ­è¡Œç½®æ›
 * âœ… è¿½åŠ æ„å›³ï¼ˆ=æ›¸ãæ›ãˆã§å†…åŒ…ï¼‰ï¼š
 * - èƒŒæ™¯ã‚’è¶³ã•ãšã«ã€Œæ¨é‡èªã ã‘ã€ã‚’è½ã¨ã—ã¦æ–­å®šã‚’ç· ã‚ã‚‹ï¼ˆæ„å‘³ã¯å¢—ã‚„ã•ãªã„ï¼‰
 */
function restoreOnePointInOutput(args: { llmOut: string; onePoint: string }): string {
  // âœ… æ¨é‡èªã ã‘ã‚’æœ€å°ç½®æ›ã§è½ã¨ã™ï¼ˆèƒŒæ™¯æ¨æ¸¬ã¯ä¸€åˆ‡ã—ãªã„ï¼‰
  const stripHedgeLite = (s: string) => {
    let t = String(s ?? '');

    // â€œã‹ã‚‚ã—ã‚Œã¾ã›ã‚“â€ç³»ã ã‘ã‚’æœ€å°é™ã§ç· ã‚ã‚‹
    t = t.replace(/ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“/g, 'æ„Ÿã˜ãŒã‚ã‚‹ã€‚');
    t = t.replace(/ã‹ã‚‚ã—ã‚Œãªã„/g, 'æ„Ÿã˜ãŒã‚ã‚‹');
    t = t.replace(/ã‚‚ã—ã‹ã—ãŸã‚‰/g, '');
    t = t.replace(/ã§ã—ã‚‡ã†/g, 'ã€‚');
    t = t.replace(/\bã‹ã‚‚\b/g, '');

    // å¥ç‚¹ã®è»½ã„æ•´å½¢
    t = t.replace(/ã€‚\s*ã€‚\s*/g, 'ã€‚');
    return t;
  };

  const rawText0 = String(args.llmOut ?? '');
  const needleRaw = String(args.onePoint ?? '').trim();
  if (!rawText0.trim() || !needleRaw) return stripHedgeLite(rawText0);

  // needle ã¯å¿…ãš "ã„ã¾ã®ä¸€ç‚¹ï¼š" å½¢å¼ã«æ­£è¦åŒ–
  const needle = needleRaw.startsWith('ã„ã¾ã®ä¸€ç‚¹ï¼š') ? needleRaw : `ã„ã¾ã®ä¸€ç‚¹ï¼š${needleRaw}`;

  // æ—¢ã«å…¥ã£ã¦ã‚‹ãªã‚‰ï¼šæ¨é‡èªã ã‘è½ã¨ã—ã¦è¿”ã™
  if (normLite(rawText0).includes(normLite(needle))) return stripHedgeLite(rawText0);

  const lines = rawText0
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .split('\n')
    .map((x) => x.trim())
    .filter(Boolean);

  if (!lines.length) return stripHedgeLite(needle);

  // (1) ã€Œã„ã¾ã®ä¸€ç‚¹ï¼šã€è¡ŒãŒã‚ã‚Œã°å·®ã—æ›¿ãˆã‚‹
  for (let i = 0; i < lines.length; i++) {
    if (lines[i]!.startsWith('ã„ã¾ã®ä¸€ç‚¹ï¼š')) {
      lines[i] = needle;
      return stripHedgeLite(lines.join('\n'));
    }
  }

  // (2) scaffold purpose ã®ç›´å¾Œã«æŒ¿å…¥
  const idxPurpose = lines.findIndex((x) => x.includes(SCAFFOLD_PURPOSE));
  if (idxPurpose >= 0) {
    lines.splice(idxPurpose + 1, 0, needle);
    return stripHedgeLite(lines.join('\n'));
  }

  // (3) ä¿é™ºï¼šå…ˆé ­è¡Œã‚’ç½®æ›
  lines[0] = needle;
  return stripHedgeLite(lines.join('\n'));
}

/**
 * âœ… scaffoldï¼ˆONE_POINT packï¼‰ä¸­ã® â€œmust-have æ§‹é€ â€ ãƒã‚§ãƒƒã‚¯ï¼ˆæ„å‘³å›ºå®šç‰ˆï¼‰
 * - å›ºå®šæ–‡è¨€ä¸€è‡´ã¯ã‚„ã‚ã‚‹
 * - å¿…é ˆã¯ã€Œæ„å‘³ï¼ˆå½¹å‰²ï¼‰ã€ã ã‘ï¼š
 *   1) è¶³å ´ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆç­”ãˆã‚’æ¸¡ã•ãªã„/è¶³å ´ã‚’ç½®ãï¼‰
 *   2) ä¸€ç‚¹ï¼ˆç„¦ç‚¹/ä¸€ç‚¹/æ³¨ç›®ç‚¹ï¼‰
 *   3) è¦‹ã‚‹è»¸ï¼ˆ2å€‹ä»¥ä¸Šï¼šä¾‹=ã‚¿ã‚¤ãƒŸãƒ³ã‚°/å®ˆã‚‹ç†ç”±/å¼•ã£ã‹ã‹ã‚Šï¼‰
 *
 * â€» æ–‡å­—åˆ—ãƒ†ãƒ³ãƒ—ãƒ¬å¾©å…ƒã§ãªãã€è¶³ã‚Šãªã„â€œæ„å‘³â€ã ã‘ã‚’è£œã†ã€‚
 */

type ScaffoldNeed = 'NEED_FRAME' | 'NEED_ONE_POINT' | 'NEED_AXES';

function scaffoldMustHaveOk(args: {
  slotKeys: string[];
  slotsForGuard: Array<{ key?: string; text?: string; content?: string; value?: string }> | null;
  llmOut: string;
}): { ok: boolean; missing: string[] } {
  const out = normLite(args.llmOut);
  if (!out) return { ok: false, missing: ['OUT_EMPTY'] };

  // scaffold ãŒç™ºç«ã—ã¦ãªã„ãªã‚‰ä½•ã‚‚ã—ãªã„
  if (!shouldEnforceOnePointGuard(args.slotKeys)) return { ok: true, missing: [] };

  const slots = Array.isArray(args.slotsForGuard) ? args.slotsForGuard : [];
  const take = (s: any) => normLite(String(s?.text ?? s?.content ?? s?.value ?? ''));

  // ------- æ§‹é€ ã‚¹ãƒ­ãƒƒãƒˆç´ æï¼ˆã‚ã‚Œã°ä½¿ã†ï¼‰ -------
  const purposeSlot = slots.find((x: any) => /PURPOSE/i.test(String(x?.key ?? '')));
  const onePointSlot = slots.find((x: any) => /ONE_POINT/i.test(String(x?.key ?? '')));
  const points3Slot = slots.find((x: any) => /POINTS_3/i.test(String(x?.key ?? '')));

  const purposeNeedle = purposeSlot ? take(purposeSlot) : '';
  const onePointNeedle = onePointSlot ? take(onePointSlot) : '';
  const points3Needle = points3Slot ? take(points3Slot) : '';

  // âœ… scaffoldä¸­ã¯ã€Œæ§‹é€ ï¼ˆslotsï¼‰ãŒæƒã£ã¦ã„ã‚‹ã€ã“ã¨ã‚’æœ€å„ªå…ˆã§OKã«ã™ã‚‹
  // - LLMæœ¬æ–‡ã®è¨€ã„æ›ãˆã§ false negative ã‚’å‡ºã•ãªã„ãŸã‚
  const hasPurposeSlot = !!(purposeSlot && take(purposeSlot));
  const hasOnePointSlot = !!(onePointSlot && take(onePointSlot));
  const hasPoints3Slot = !!(points3Slot && take(points3Slot));

  if (hasPurposeSlot && hasOnePointSlot && hasPoints3Slot) {
    return { ok: true, missing: [] };
  }


  // ------- æ„å‘³æ¤œå‡ºï¼ˆå›ºå®šæ–‡è¨€ã§ã¯ãªãã€å½¹å‰²ã®å­˜åœ¨ï¼‰ -------
  // 1) è¶³å ´ãƒ•ãƒ¬ãƒ¼ãƒ ï¼šç­”ãˆã‚’æ¸¡ã•ãªã„/è¶³å ´/ã„ã¾ã¯æ±ºã‚ãªã„â€¦ç³»ã®â€œå§¿å‹¢â€
  const hasFrame =
    /(ç­”ãˆã‚’æ¸¡ã•|è¶³å ´|ã„ã¾ã¯(çµè«–|ç­”ãˆ)ã‚’(å‡ºã•|æ€¥ãŒ)|æ±ºã‚ãªãã¦|ã¾ãš.*(ç½®ã|ä½œã‚‹))/u.test(out) ||
    (purposeNeedle && out.includes(purposeNeedle.slice(0, Math.min(18, purposeNeedle.length))));

  // 2) ä¸€ç‚¹ï¼šä¸€ç‚¹/ç„¦ç‚¹/ã“ã“ã§è¦‹ã‚‹ã®ã¯ä¸€ã¤â€¦ç³»
  const hasOnePoint =
    /(ã„ã¾ã®ä¸€ç‚¹|ä¸€ç‚¹|ç„¦ç‚¹|ã“ã“ã§è¦‹(ãŸã„|ã‚‹)ã®ã¯|æ³¨ç›®(ç‚¹)?)/u.test(out) ||
    (onePointNeedle && out.includes(onePointNeedle.slice(0, Math.min(10, onePointNeedle.length))));

  // 3) è¦‹ã‚‹è»¸ï¼š2è»¸ä»¥ä¸ŠãŒâ€œæœ¬æ–‡ã«æ®‹ã£ã¦ã„ã‚‹â€ã“ã¨ï¼ˆ3å›ºå®šã§ã¯ãªã„ï¼‰
  // points3Slot ãŒã‚ã‚‹å ´åˆã¯ã€Œãƒ©ãƒ™ãƒ«ã€æŠ½å‡ºã—ã¦ 2å€‹ä»¥ä¸Šãƒ’ãƒƒãƒˆã§OK
  const axesLabels = (() => {
    if (!points3Needle) return [];
    return points3Needle
      .replace(/\r\n/g, '\n')
      .replace(/\r/g, '\n')
      .split('\n')
      .map((x) => x.trim())
      .filter(Boolean)
      .map((x) => x.replace(/^[ãƒ»\-\*\u2022]\s*/g, ''))
      .map((x) => {
        const i = x.indexOf('ï¼ˆ');
        return (i >= 0 ? x.slice(0, i) : x).trim();
      })
      .filter((x) => x.length >= 2)
      .slice(0, 4);
  })();

  const axesHits = axesLabels.filter((lb) => out.includes(lb));
  const hasAxes =
    // æ˜ç¤ºçš„ã«ã€Œè¦‹ã‚‹å ´æ‰€ã¯3ã¤ã ã‘ã€ã‚’å¿…é ˆã«ã—ãªã„ï¼ˆã‚ã£ã¦ã‚‚OKï¼‰
    axesHits.length >= 2 ||
    // ä»£æ›¿ï¼šæœ¬æ–‡ã« â€œå‰/æœ€ä¸­/å¾Œâ€ ã‚„ â€œå®ˆã‚‹ç†ç”±â€ â€œã‚¿ã‚¤ãƒŸãƒ³ã‚°â€ â€œå¼•ã£ã‹ã‹ã‚Šâ€ ãŒ2ç³»çµ±ä»¥ä¸Šã‚ã‚Œã°OK
    (() => {
      const a1 = /(ã‚¿ã‚¤ãƒŸãƒ³ã‚°|å‰\s*\/\s*æœ€ä¸­\s*\/\s*å¾Œ|ã„ã¤å‡ºã‚‹)/u.test(out);
      const a2 = /(å®ˆã‚‹ç†ç”±|å¤±ã„ãŸããªã„|å®ˆã£ã¦ã‚‹|ä¿ã£ã¦ã‚‹)/u.test(out);
      const a3 = /(å¼•ã£ã‹ã‹|æ­¢ã‚ã¦ã‚‹|æ­¢ã¾ã‚‹|ã²ã£ã‹ã‹)/u.test(out);
      const c = [a1, a2, a3].filter(Boolean).length;
      return c >= 2;
    })();

  const missing: string[] = [];
  if (!hasFrame) missing.push('SCAFFOLD_NEED_FRAME');
  if (!hasOnePoint) missing.push('SCAFFOLD_NEED_ONE_POINT');
  if (!hasAxes) missing.push('SCAFFOLD_NEED_AXES');

  return { ok: missing.length === 0, missing };
}

/**
 * âœ… scaffold must-have ã®å¾©å…ƒï¼ˆæ„å‘³è£œå®Œç‰ˆï¼‰
 * - å›ºå®šãƒ†ãƒ³ãƒ—ãƒ¬ã‚’è²¼ã‚‰ãªã„
 * - è¶³ã‚Šãªã„â€œæ„å‘³â€ã ã‘ã€çŸ­ã„ä¸€æ–‡ã‚’è¶³ã™
 * - è¡¨ç¾ã¯ã€Œæ±ºå®šçš„ã«åŒã˜ã€ã«ãªã‚‰ãªã„ã‚ˆã†ã«è»½ãæºã‚‰ã™ï¼ˆæ±ºå®šè«–ãƒ»å®‰å®šï¼‰
 */
function restoreScaffoldMustHaveInOutput(args: {
  llmOut: string;
  slotsForGuard: Array<{ key?: string; text?: string; content?: string; value?: string }> | null;
  missing: string[];
}): string {
  let out = String(args.llmOut ?? '');
  const slots = Array.isArray(args.slotsForGuard) ? args.slotsForGuard : [];
  const take = (s: any) => normLite(String(s?.text ?? s?.content ?? s?.value ?? ''));

  const purposeSlot = slots.find((x: any) => /PURPOSE/i.test(String(x?.key ?? '')));
  const onePointSlot = slots.find((x: any) => /ONE_POINT/i.test(String(x?.key ?? '')));
  const points3Slot = slots.find((x: any) => /POINTS_3/i.test(String(x?.key ?? '')));

  const purposeNeedle = purposeSlot ? take(purposeSlot) : '';
  const onePointNeedle = onePointSlot ? take(onePointSlot) : '';
  const points3Needle = points3Slot ? take(points3Slot) : '';

  const miss = new Set((args.missing ?? []).map((x) => String(x)));

  // â€œæ¯å›åŒã˜â€ã«ãªã‚Šã«ãã„æºã‚‰ã—ï¼ˆæ±ºå®šè«–ï¼‰ï¼šé•·ã•ã§åˆ†å²
  const k = (normLite(out).length + normLite(onePointNeedle).length) % 3;

  const addFrame = () => {
    const v =
      k === 0
        ? 'ã“ã“ã§ã¯ç­”ãˆã‚’æ¸¡ã—ã¾ã›ã‚“ã€‚ã‚ãªãŸãŒç­”ãˆã‚’å‡ºã›ã‚‹ä½ç½®ã«è¶³å ´ã‚’ç½®ãã¾ã™ã€‚'
        : k === 1
          ? 'ã„ã¾ã¯çµè«–ã‚’æ€¥ãŒãªã„ã€‚è€ƒãˆã‚‹ãŸã‚ã®è¶³å ´ã ã‘æ•´ãˆã¾ã™ã€‚'
          : 'ç­”ãˆã‚’æ±ºã‚ã‚‹å‰ã«ã€ã¾ãšâ€œè€ƒãˆãŒå‹•ãå ´æ‰€â€ã‚’ä½œã‚Šã¾ã™ã€‚';
    out = v + '\n' + out;
  };

  const addOnePoint = () => {
    // onePointSlotãŒã‚ã‚Œã°ãã‚Œã‚’å„ªå…ˆã—ã¦â€œè‡ªç„¶æ–‡â€ã§å·®ã—è¾¼ã‚€
    const base = onePointNeedle
      ? onePointNeedle.replace(/^ã„ã¾ã®ä¸€ç‚¹[:ï¼š]\s*/u, '').trim()
      : '';
    const v =
      base
        ? `ä»Šã“ã“ã§æ‰±ã†ç„¦ç‚¹ã¯ã²ã¨ã¤ï¼š${base}`
        : k === 0
          ? 'ä»Šã“ã“ã§æ‰±ã†ç„¦ç‚¹ã¯ã²ã¨ã¤ã ã‘ã«ã—ã¾ã™ã€‚'
          : k === 1
            ? 'è©±ã‚’é€²ã‚ã‚‹ãŸã‚ã«ã€ã¾ãšä¸€ç‚¹ã«å¯„ã›ã¾ã™ã€‚'
            : 'ã¾ãšä¸€ã¤ã«çµã‚‹ï¼šã„ã¾å¼•ã£ã‹ã‹ã£ã¦ã„ã‚‹ä¸€ç‚¹ã ã‘ã‚’è¦‹ã‚‹ã€‚';
    out = out + '\n' + v;
  };

  const addAxes = () => {
    // points3SlotãŒã‚ã‚Œã°ã€Œ2è»¸ã ã‘ã€æœ¬æ–‡ã«æº¶ã‹ã™ï¼ˆç®‡æ¡æ›¸ãå›ºå®šã«ã—ãªã„ï¼‰
    const labels = (() => {
      if (!points3Needle) return [];
      const bad = (s: string) =>
        /(è¦‹ã‚‹å ´æ‰€ã¯3ã¤ã ã‘|è¦‹ã‚‹è»¸|ã„ã¾ã®ä¸€ç‚¹|ä»Šã“ã“ã§æ‰±ã†|ç„¦ç‚¹|è¶³å ´|ç­”ãˆã‚’æ¸¡ã•)/u.test(s);

      return points3Needle
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n')
        .split('\n')
        .map((x) => x.trim())
        .filter(Boolean)
        .map((x) => x.replace(/^[ãƒ»\-\*\u2022]\s*/g, ''))
        .map((x) => {
          const i = x.indexOf('ï¼ˆ');
          return (i >= 0 ? x.slice(0, i) : x).trim();
        })
        .map((x) => x.replace(/[:ï¼š]\s*$/u, '').trim())
        .filter((x) => x.length >= 2)
        .filter((x) => !bad(x)) // âœ… è¦‹å‡ºã—/æ ã‚’ãƒ©ãƒ™ãƒ«ã‹ã‚‰é™¤å¤–
        .slice(0, 4);
    })();

    // 2è»¸ã ã‘æ¡ç”¨ï¼ˆå›ºå®š3ç‚¹ã«ã—ãªã„ï¼‰
    const pick2 = labels.length >= 2 ? labels.slice(0, 2) : labels;

    const v =
      pick2.length >= 2
        ? `è¦‹ã‚‹è»¸ã¯ã“ã®2ã¤ã ã‘æ®‹ã—ã¦ãŠã‘ã°è¶³ã‚Šã¾ã™ï¼š${pick2[0]}ï¼${pick2[1]}ã€‚`
        : k === 0
          ? 'è¦‹ã‚‹è»¸ã¯2ã¤ã ã‘æ®‹ã›ã°é€²ã¿ã¾ã™ï¼ˆä¾‹ï¼šå‡ºã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ï¼å®ˆã£ã¦ã„ã‚‹ç†ç”±ï¼‰ã€‚'
          : k === 1
            ? 'ç¢ºèªã™ã‚‹ã®ã¯2ç‚¹ã ã‘ã§ã„ã„ï¼ˆã„ã¤å‡ºã‚‹ã‹ï¼ä½•ã‚’å®ˆã£ã¦ã‚‹ã‹ï¼‰ã€‚'
            : 'è¦‹ã‚‹å ´æ‰€ã‚’å¢—ã‚„ã•ãªã„ã€‚2ç‚¹ã ã‘ã§å‹•ã‹ã™ï¼ˆã‚¿ã‚¤ãƒŸãƒ³ã‚°ã¨ç†ç”±ï¼‰ã€‚';

    out = out + '\n' + v;
  };

  // missing ã«å¿œã˜ã¦â€œæ„å‘³â€ã ã‘è£œå®Œ
  if (miss.has('SCAFFOLD_NEED_FRAME')) {
    // purposeNeedle ãŒãã®ã¾ã¾å›ºå®šæ–‡ã«ãªã£ã¦ã„ã‚‹ãªã‚‰è²¼ã‚‰ãªã„ï¼ˆä¸Šã®å¯å¤‰æ–‡ã§ç½®ãæ›ãˆã‚‹ï¼‰
    addFrame();
  }

  if (miss.has('SCAFFOLD_NEED_ONE_POINT')) {
    addOnePoint();
  }

  if (miss.has('SCAFFOLD_NEED_AXES')) {
    addAxes();
  }

  return out;
}



// ---------------------------------------------
// ITæˆç«‹ï¼ˆè¨¼æ‹ ï¼‰ã‚’ userContext ã‹ã‚‰èª­ã‚€
// ---------------------------------------------
function readItOkFromContext(userContext: unknown): boolean {
  if (!userContext || typeof userContext !== 'object') return false;
  const uc: any = userContext as any;

  const reason =
    norm(
      tryGet(uc, ['itxReason']) ??
        tryGet(uc, ['itx_reason']) ??
        tryGet(uc, ['meta', 'itxReason']) ??
        tryGet(uc, ['meta', 'itx_reason']) ??
        tryGet(uc, ['ctxPack', 'itxReason']) ??
        tryGet(uc, ['ctxPack', 'itx_reason']) ??
        tryGet(uc, ['ctx_pack', 'itxReason']) ??
        tryGet(uc, ['ctx_pack', 'itx_reason']) ??
        '',
    ) || '';

  const tLayerModeActive =
    Boolean(
      tryGet(uc, ['tLayerModeActive']) ??
        tryGet(uc, ['meta', 'tLayerModeActive']) ??
        tryGet(uc, ['ctxPack', 'tLayerModeActive']) ??
        tryGet(uc, ['ctx_pack', 'tLayerModeActive']) ??
        false,
    ) === true;

  const itxStep =
    norm(
      tryGet(uc, ['itxStep']) ??
        tryGet(uc, ['itx_step']) ??
        tryGet(uc, ['meta', 'itxStep']) ??
        tryGet(uc, ['meta', 'itx_step']) ??
        tryGet(uc, ['ctxPack', 'itxStep']) ??
        tryGet(uc, ['ctxPack', 'itx_step']) ??
        tryGet(uc, ['ctx_pack', 'itxStep']) ??
        tryGet(uc, ['ctx_pack', 'itx_step']) ??
        tryGet(uc, ['memoryState', 'itxStep']) ??
        tryGet(uc, ['memoryState', 'itx_step']) ??
        tryGet(uc, ['orchestratorState', 'itxStep']) ??
        tryGet(uc, ['orchestratorState', 'itx_step']) ??
        tryGet(uc, ['last_state', 'itxStep']) ??
        tryGet(uc, ['last_state', 'itx_step']) ??
        '',
    ) || '';

  const itxOk = itxStep ? /^[T][123]$/u.test(itxStep) : false;

  if (reason.includes('IT_TRIGGER_OK')) return true;
  if (reason.includes('IT_HOLD')) return true;
  if (tLayerModeActive) return true;
  if (itxOk) return true;

  return false;
}

// ---------------------------------------------
// intentBand / tLayerHint ã‚’ userContext ã‹ã‚‰æŠ½å‡º
// ---------------------------------------------
function extractIntentBandFromContext(userContext: unknown): {
  intentBand: string | null;
  tLayerHint: string | null;
} {
  if (!userContext || typeof userContext !== 'object') {
    return { intentBand: null, tLayerHint: null };
  }
  const uc: any = userContext as any;

  const intentBand =
    norm(
      tryGet(uc, ['intentBand']) ??
        tryGet(uc, ['intent_band']) ??
        tryGet(uc, ['ctxPack', 'intentBand']) ??
        tryGet(uc, ['ctxPack', 'intent_band']) ??
        tryGet(uc, ['ctx_pack', 'intentBand']) ??
        tryGet(uc, ['ctx_pack', 'intent_band']) ??
        tryGet(uc, ['memoryState', 'intentBand']) ??
        tryGet(uc, ['memoryState', 'intent_band']) ??
        tryGet(uc, ['orchestratorState', 'intentBand']) ??
        tryGet(uc, ['orchestratorState', 'intent_band']) ??
        tryGet(uc, ['last_state', 'intentBand']) ??
        tryGet(uc, ['last_state', 'intent_band']) ??
        '',
    ) || null;

  const tLayerHintRaw =
    norm(
      tryGet(uc, ['tLayerHint']) ??
        tryGet(uc, ['t_layer_hint']) ??
        tryGet(uc, ['ctxPack', 'tLayerHint']) ??
        tryGet(uc, ['ctxPack', 't_layer_hint']) ??
        tryGet(uc, ['ctx_pack', 'tLayerHint']) ??
        tryGet(uc, ['ctx_pack', 't_layer_hint']) ??
        '',
    ) || null;

  const itxStep =
    norm(
      tryGet(uc, ['itxStep']) ??
        tryGet(uc, ['itx_step']) ??
        tryGet(uc, ['meta', 'itxStep']) ??
        tryGet(uc, ['meta', 'itx_step']) ??
        tryGet(uc, ['ctxPack', 'itxStep']) ??
        tryGet(uc, ['ctxPack', 'itx_step']) ??
        tryGet(uc, ['ctx_pack', 'itxStep']) ??
        tryGet(uc, ['ctx_pack', 'itx_step']) ??
        tryGet(uc, ['memoryState', 'itxStep']) ??
        tryGet(uc, ['memoryState', 'itx_step']) ??
        tryGet(uc, ['orchestratorState', 'itxStep']) ??
        tryGet(uc, ['orchestratorState', 'itx_step']) ??
        tryGet(uc, ['last_state', 'itxStep']) ??
        tryGet(uc, ['last_state', 'itx_step']) ??
        '',
    ) || '';

  const tLayerHint = tLayerHintRaw || (itxStep ? itxStep : null);

  const bandOk = intentBand && /^[SRICT][123]$/u.test(intentBand) ? intentBand : null;
  const hintOk = tLayerHint && /^(?:[SRICT][123]|T[123])$/u.test(tLayerHint) ? tLayerHint : null;

  return { intentBand: bandOk, tLayerHint: hintOk };
}

// ---------------------------------------------
// shouldRaiseFlagï¼ˆPOSITION_DRIFT / STALL ç­‰ï¼‰ã‚’ userContext ã‹ã‚‰èª­ã‚€
// ---------------------------------------------
function readShouldRaiseFlagFromContext(
  userContext: unknown,
): { on: boolean; reason: string | null } {
  if (!userContext || typeof userContext !== 'object') return { on: false, reason: null };
  const uc: any = userContext as any;

  const on =
    (Boolean(
      tryGet(uc, ['shouldRaiseFlag']) ??
        tryGet(uc, ['meta', 'shouldRaiseFlag']) ??
        tryGet(uc, ['meta', 'extra', 'shouldRaiseFlag']) ??
        tryGet(uc, ['extra', 'shouldRaiseFlag']) ??
        tryGet(uc, ['ctxPack', 'shouldRaiseFlag']) ??
        tryGet(uc, ['ctxPack', 'meta', 'extra', 'shouldRaiseFlag']) ??
        tryGet(uc, ['ctx_pack', 'shouldRaiseFlag']) ??
        tryGet(uc, ['ctx_pack', 'meta', 'extra', 'shouldRaiseFlag']) ??
        tryGet(uc, ['memoryState', 'shouldRaiseFlag']) ??
        tryGet(uc, ['orchestratorState', 'shouldRaiseFlag']) ??
        false,
    ) === true);

  const reasonsRaw =
    (tryGet(uc, ['flagReasons']) ??
      tryGet(uc, ['flag_reasons']) ??
      tryGet(uc, ['meta', 'flagReasons']) ??
      tryGet(uc, ['meta', 'flag_reasons']) ??
      tryGet(uc, ['meta', 'extra', 'flagReasons']) ??
      tryGet(uc, ['meta', 'extra', 'flag_reasons']) ??
      tryGet(uc, ['extra', 'flagReasons']) ??
      tryGet(uc, ['extra', 'flag_reasons']) ??
      tryGet(uc, ['ctxPack', 'flagReasons']) ??
      tryGet(uc, ['ctxPack', 'flag_reasons']) ??
      tryGet(uc, ['ctxPack', 'meta', 'extra', 'flagReasons']) ??
      tryGet(uc, ['ctxPack', 'meta', 'extra', 'flag_reasons']) ??
      tryGet(uc, ['ctx_pack', 'flagReasons']) ??
      tryGet(uc, ['ctx_pack', 'flag_reasons']) ??
      tryGet(uc, ['ctx_pack', 'meta', 'extra', 'flagReasons']) ??
      tryGet(uc, ['ctx_pack', 'meta', 'extra', 'flag_reasons']) ??
      null) as any;

  let reasonFromArray: string | null = null;
  if (Array.isArray(reasonsRaw) && reasonsRaw.length > 0) {
    reasonFromArray = norm(String(reasonsRaw[0] ?? '')) || null;
  } else if (typeof reasonsRaw === 'string') {
    const first = reasonsRaw.split(/[,\s|]+/).filter(Boolean)[0];
    reasonFromArray = norm(String(first ?? '')) || null;
  }

  const reasonSingle =
    norm(
      String(
        tryGet(uc, ['flagReason']) ??
          tryGet(uc, ['flag_reason']) ??
          tryGet(uc, ['meta', 'flagReason']) ??
          tryGet(uc, ['meta', 'flag_reason']) ??
          tryGet(uc, ['meta', 'extra', 'flagReason']) ??
          tryGet(uc, ['meta', 'extra', 'flag_reason']) ??
          tryGet(uc, ['extra', 'flagReason']) ??
          tryGet(uc, ['extra', 'flag_reason']) ??
          tryGet(uc, ['ctxPack', 'flagReason']) ??
          tryGet(uc, ['ctxPack', 'flag_reason']) ??
          tryGet(uc, ['ctxPack', 'meta', 'extra', 'flagReason']) ??
          tryGet(uc, ['ctxPack', 'meta', 'extra', 'flag_reason']) ??
          tryGet(uc, ['ctx_pack', 'flagReason']) ??
          tryGet(uc, ['ctx_pack', 'flag_reason']) ??
          tryGet(uc, ['ctx_pack', 'meta', 'extra', 'flagReason']) ??
          tryGet(uc, ['ctx_pack', 'meta', 'extra', 'flag_reason']) ??
          '',
      ),
    ) || null;

  const reason = reasonFromArray ?? reasonSingle;

  return { on, reason };
}

// ---------------------------------------------
// inputKind
// ---------------------------------------------
function extractInputKindFromMetaText(metaText: string): string | null {
  const t = String(metaText ?? '');

  {
    const m = t.match(/"inputKind"\s*:\s*"([^"]+)"/);
    if (m?.[1]) return String(m[1]).trim().toLowerCase();
  }

  {
    const m = t.match(/\binputKind\b\s*[:=]\s*([A-Za-z_][A-Za-z0-9_]*)/);
    if (m?.[1]) return String(m[1]).trim().toLowerCase();
  }

  return null;
}

function extractInputKindFromContext(ctx: any): string | null {
  if (!ctx) return null;

  const candidates = [
    ctx.inputKind,
    ctx.kind,
    ctx.framePlan?.inputKind,
    ctx.framePlan?.kind,
    ctx.meta?.inputKind,
    ctx.meta?.kind,
    ctx.ctx?.inputKind,
    ctx.ctx?.framePlan?.inputKind,
  ];

  for (const v of candidates) {
    if (typeof v === 'string' && v.trim()) return v.trim().toLowerCase();
  }
  return null;
}

function adaptSeedDraftHintForWriter(seedDraft: string, directTask: boolean): string {
  const s = String(seedDraft ?? '').trim();
  if (!s) return '';

  let out = s;

  // seedDraft ã« find_trigger_point ã®ç—•è·¡ãŒæ··ã–ã‚‹å ´åˆã®ä¿é™º
  if (/find_trigger_point/i.test(out)) {
    out = out.replace(/.*find_trigger_point.*(\n|$)/gi, '').trim();
    const hint = directTask
      ? 'ï¼ˆå†…éƒ¨ãƒ’ãƒ³ãƒˆï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã€Œå…·ä½“çš„ãªã‚³ãƒ„/æ‰‹é †ã€ã‚’æ±‚ã‚ã¦ã„ã‚‹ã€‚æœ€åˆã«ä½¿ãˆã‚‹å…·ä½“ç­–ã‚’çŸ­ãå‡ºã™ï¼‰'
      : 'ï¼ˆå†…éƒ¨ãƒ’ãƒ³ãƒˆï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ±‚ã‚ã¦ã„ã‚‹ä¸€ç‚¹ã‚’ã€Œè»¸ã€ã¨ã—ã¦ç½®ãï¼‰';
    return [hint, out].filter(Boolean).join('\n');
  }

  if (directTask) return ['ï¼ˆå†…éƒ¨ãƒ’ãƒ³ãƒˆï¼šå…·ä½“ç­–ã‚’å…ˆã«ã€‚ä¸€èˆ¬è«–ã¯è¶³ã•ãªã„ï¼‰', out].join('\n');
  return out;
}

// ---------------------------------------------
// logs
// ---------------------------------------------
function logRephraseOk(
  debug: DebugFinal | null | undefined,
  outKeys: string[],
  raw: string,
  mode?: string,
) {
  console.log('[IROS/rephraseEngine][OK]', {
    traceId: debug?.traceId ?? null,
    conversationId: debug?.conversationId ?? null,
    userCode: debug?.userCode ?? null,
    mode: mode ?? null,
    keys: outKeys,
    rawLen: String(raw ?? '').length,
    rawHead: safeHead(String(raw ?? ''), 120),
  });
}

function logRephraseAfterAttach(
  debug: DebugFinal | null | undefined,
  outKeys: string[],
  firstText: string,
  mode?: string,
) {
  console.log('[IROS/rephraseEngine][AFTER_ATTACH]', {
    traceId: debug?.traceId ?? null,
    conversationId: debug?.conversationId ?? null,
    userCode: debug?.userCode ?? null,
    mode: mode ?? null,
    renderEngine: debug?.renderEngine ?? true,
    rephraseBlocksLen: outKeys.length,
    rephraseHead: safeHead(String(firstText ?? ''), 120),
  });
}

// ---------------------------------------------
// system promptï¼ˆæ–¹å‘ã¥ã‘ / éœ²å‡ºç¦æ­¢ï¼‰
// ---------------------------------------------
function systemPromptForFullReply(args?: {
  directTask?: boolean;
  itOk?: boolean;
  band?: { intentBand: string | null; tLayerHint: string | null } | null;
  lockedILines?: string[] | null;
}): string {
  const directTask = Boolean(args?.directTask);
  const itOk = Boolean(args?.itOk);
  const band = args?.band ?? null;

  const b = band?.intentBand ?? null;
  const h = band?.tLayerHint ?? null;

  const isIRequested = (b && b.startsWith('I')) || (h && h.startsWith('I'));
  const allowIStyle = itOk && isIRequested;

  const base = directTask
    ? [
        'ã‚ãªãŸã¯ iros ã®ä¼šè©±ç”Ÿæˆï¼ˆreplyï¼‰æ‹…å½“ã§ã™ã€‚',
        '',
        'ã€æ——å°ã€‘',
        'ç­”ãˆã‚’æ¸¡ã•ãªã„ã€‚åˆ¤æ–­ã‚’æ€¥ãŒã›ãªã„ã€‚èª­ã¿æ‰‹ãŒè‡ªåˆ†ã§ç­”ãˆã‚’å‡ºã›ã‚‹å ´æ‰€ã‚’ã¤ãã‚‹ã€‚',
        '',
        'ã€å‡ºåŠ›ãƒ«ãƒ¼ãƒ«ï¼ˆdirectTask=TRUEï¼‰ã€‘',
        '- å…¨ä½“ã§6ã€œ14è¡Œã€‚ä¼šè©±æ–‡ã®ã¿ã€‚',
        '- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä¾é ¼ã«å¯¾ã—ã¦ã€Œãã®ã¾ã¾é€ã‚Œã‚‹æ–‡é¢ã€ã‚’å‡ºã™ã€‚',
        '- ãŸã ã—â€œæ­£è§£/çµè«–/å®‰å¿ƒâ€ã§é–‰ã˜ãªã„ã€‚ç›¸æ‰‹ã®ä¸»æ¨©ãŒæ®‹ã‚‹ä½™ç™½ã§çµ‚ãˆã‚‹ã€‚',
        '- æ–‡é¢ã¯ã€Œäº‹å®Ÿâ†’å¢ƒç•Œâ†’ä½™ç™½ã€ã®é †ã§çµ„ã‚€ã€‚',
        '',
        'ã€ç¦æ­¢ãƒ»æ³¨æ„ã€‘',
        '- å‘½ä»¤ï¼ˆã€œã™ã¹ã/å¿…ãš/çµ¶å¯¾ï¼‰ã§ç›¸æ‰‹ã‚’å‹•ã‹ã•ãªã„ã€‚',
        '- æ–­è¨€ã§èƒŒä¸­ã‚’æŠ¼ã—åˆ‡ã‚‰ãªã„ï¼ˆæ±ºã‚ãªã„ï¼‰ã€‚',
        '- ãƒ†ãƒ³ãƒ—ãƒ¬å£ç™–ï¼ˆå—ã‘å–ã£ãŸ/ã„ã¾å‡ºã¦ã„ã‚‹è¨€è‘‰/ä¸€æ‰‹ã«è½ã¨ã™/å‘¼å¸ã‚’æˆ»ã™ ç­‰ï¼‰ã¯ä½¿ã‚ãªã„ã€‚',
        '- A/Bã®äºŒæŠã§é¸ã°ã›ãªã„ï¼ˆä¸¦ã¹ã¦ã‚‚ã€é¸æŠã‚’è¿«ã‚‰ãªã„ï¼‰ã€‚',
        '- å…¥åŠ›ãƒ¡ã‚¿ï¼ˆphase/depth/q/JSON/ã‚­ãƒ¼åï¼‰ã¯æœ¬æ–‡ã«å‡ºã•ãªã„ã€‚',
        '- ã€Œè¦šãˆã¦ã„ã‚‹ã€ã€Œå‰ã«è¨€ã£ã¦ã„ãŸã€ç­‰ã®è¨˜æ†¶æ–­è¨€ã¯ã—ãªã„ã€‚',
        '- çµ‚ç«¯è¨˜å·ï¼ˆğŸª”ãªã©ï¼‰ã¯å‡ºã•ãªã„ï¼ˆä¸Šä½ãƒ¬ãƒ³ãƒ€ãƒ¼ãŒä»˜ã‘ã‚‹ï¼‰ã€‚',
        '- å•ã„ã¯æœ€å¤§1ã¤ã€‚ä¸è¦ãªã‚‰0ã€‚',
      ].join('\n')
    : [
        'ã‚ãªãŸã¯ iros ã®ä¼šè©±ç”Ÿæˆï¼ˆreplyï¼‰æ‹…å½“ã§ã™ã€‚',
        '',
        'ã€æ——å°ã€‘',
        'ç­”ãˆã‚’æ¸¡ã•ãªã„ã€‚åˆ¤æ–­ã‚’æ€¥ãŒã›ãªã„ã€‚èª­ã¿æ‰‹ãŒè‡ªåˆ†ã§ç­”ãˆã‚’å‡ºã›ã‚‹å ´æ‰€ã‚’ã¤ãã‚‹ã€‚',
        '',
        'ã€å‡ºåŠ›ãƒ«ãƒ¼ãƒ«ï¼ˆdirectTask=FALSEï¼‰ã€‘',
        '- å…¨ä½“ã§4ã€œ10è¡Œã€‚ä¼šè©±æ–‡ã®ã¿ã€‚',
        '- 1æ®µè½ç›®ï¼šè»¸ã‚’1æ–‡ï¼ˆè©•ä¾¡ã›ãšã€æ±ºã‚ãªã„ï¼‰ã€‚',
        '- 2æ®µè½ç›®ï¼šè¦‹ã‚‹ãƒã‚¤ãƒ³ãƒˆã‚’2ã€œ4æ–‡ï¼ˆç®‡æ¡æ›¸ãè¨˜å·ã¯ä½¿ã‚ãªã„ï¼‰ã€‚',
        '- 3æ®µè½ç›®ï¼šä½™ç™½ã‚’1æ–‡ï¼ˆè©°ã‚ãªã„ï¼‰ã€‚',
        '',
        'ã€ç¦æ­¢ãƒ»æ³¨æ„ã€‘',
        '- å‘½ä»¤ï¼ˆã€œã™ã¹ã/å¿…ãš/çµ¶å¯¾ï¼‰ã§ç›¸æ‰‹ã‚’å‹•ã‹ã•ãªã„ã€‚',
        '- ãƒ†ãƒ³ãƒ—ãƒ¬å£ç™–ï¼ˆå—ã‘å–ã£ãŸ/ã„ã¾å‡ºã¦ã„ã‚‹è¨€è‘‰/ä¸€æ‰‹ã«è½ã¨ã™/å‘¼å¸ã‚’æˆ»ã™ ç­‰ï¼‰ã¯ä½¿ã‚ãªã„ã€‚',
        '- A/Bã®äºŒæŠã§é¸ã°ã›ãªã„ï¼ˆä¸¦ã¹ã¦ã‚‚ã€é¸æŠã‚’è¿«ã‚‰ãªã„ï¼‰ã€‚',
        '- è³ªå•ã¯æœ€å¤§1ã¤ã€‚ä¸è¦ãªã‚‰è³ªå•ã¯æ›¸ã‹ãªã„ã€‚',
        '- å…¥åŠ›ãƒ¡ã‚¿ï¼ˆphase/depth/q/JSON/ã‚­ãƒ¼åï¼‰ã¯æœ¬æ–‡ã«å‡ºã•ãªã„ã€‚',
        '- ã€Œè¦šãˆã¦ã„ã‚‹ã€ã€Œå‰ã«è©±ã—ãŸã‚ˆã­ã€ç­‰ã®è¨˜æ†¶æ–­è¨€ã¯ã—ãªã„ã€‚',
        '- çµ‚ç«¯è¨˜å·ï¼ˆğŸª”ãªã©ï¼‰ã¯å‡ºã•ãªã„ï¼ˆä¸Šä½ãƒ¬ãƒ³ãƒ€ãƒ¼ãŒä»˜ã‘ã‚‹ï¼‰ã€‚',
      ].join('\n');

  // âœ… æ——å°ã‚¬ãƒ¼ãƒ‰ï¼šåŠ±ã¾ã—å®šå‹/æ¨æ¸¬é€ƒã’ã‚’æŠ‘ãˆã‚‹
  const flagshipHardNo = [
    '',
    'ã€ç¦æ­¢ï¼ˆæ——å°ã‚¬ãƒ¼ãƒ‰ï¼‰ã€‘',
    '- æ¬¡ã®â€œåŠ±ã¾ã—å®šå‹â€ã¯ç¦æ­¢ï¼š',
    '  ãƒ»ã€Œç‰¹åˆ¥ã§ã™ã­ã€ã€Œç´ æ•µã§ã™ã­ã€ã€Œã„ã„ã§ã™ã­ã€',
    '  ãƒ»ã€Œãã®æ°—æŒã¡ã‚’å¤§åˆ‡ã«ã€ã€Œå¿œæ´ã—ã¦ã‚‹ã€ã€Œãã£ã¨ã€',
    '  ãƒ»ã€Œé€²ã‚“ã§ã„ã‘ã‚‹ã¨ã„ã„ã§ã™ã­ã€ã€Œã€œã§ãã‚‹ã¨ã„ã„ã€',
    '- æ¬¡ã®â€œæ¨æ¸¬é€ƒã’â€ã¯ç¦æ­¢ï¼š',
    '  ãƒ»ã€Œã€œã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€ã€Œã€œã®ã‹ã‚‚ã€ã€Œã‚‚ã—ã‹ã—ãŸã‚‰ã€',
    '- ä»£ã‚ã‚Šã«ï¼šå…¥åŠ›ã«ã‚ã‚‹äº‹å®Ÿã ã‘ã§â€œè¦‹æ–¹ã‚’ä¸€æ®µå¤‰ãˆã‚‹èª¬æ˜â€ã‚’ç½®ãã€è³ªå•ã¯æœ€å¤§1ã¤ã€‚',
    '',
  ].join('\n');

  const bandInfo = [
    '',
    'ã€å†…éƒ¨åˆ¶ç´„ï¼šå¸¯åŸŸãƒ’ãƒ³ãƒˆï¼ˆéœ²å‡ºç¦æ­¢ï¼‰ã€‘',
    `directTask=${directTask ? 'true' : 'false'} / itOk=${itOk ? 'true' : 'false'} / intentBand=${
      b ?? '(null)'
    } / tLayerHint=${h ?? '(null)'}`,
  ].join('\n');

  const directTaskRule = directTask
    ? [
        '',
        'ã€directTask=TRUEï¼ˆé€ã‚Œã‚‹æ–‡é¢ / ä½™ç™½ã‚ã‚Šï¼‰ã€‘',
        '- ç›¸æ‰‹ã®ä¸å®‰ã‚’â€œåŸ‹ã‚ã‚‹â€æ–‡ç« ã«ã—ãªã„ã€‚',
        '- æ±ºã‚ã¤ã‘ãšã€å¢ƒç•Œã‚’ç½®ãã€ä½™ç™½ã§çµ‚ãˆã‚‹ã€‚',
      ].join('\n')
    : [
        '',
        'ã€directTask=FALSEã€‘',
        '- å†’é ­ã§ã€Œå¼•ã£ã‹ã‹ã£ã¦ã„ã‚‹ä¸€ç‚¹ã€ã‚’â€œè»¸â€ã¨ã—ã¦ç½®ãã€‚',
      ].join('\n');

  const lockRule = buildLockRuleText(args?.lockedILines ?? []);

  const iStyleRule = allowIStyle
    ? [
        '',
        'ã€Iã£ã½ã„æ–‡ä½“ï¼ˆè¨±å¯ï¼‰ã€‘',
        'çŸ­ãæ–­å®šçš„ãªæ–‡ä½“ã¯ä½¿ã£ã¦ã‚ˆã„ã€‚',
        'ãŸã ã—åŠ©è¨€/èª¬æ•™ã§åŸ‹ã‚ãªã„ã€‚ç½®ã„ãŸã‚‰è§£èª¬ã‚’è¶³ã•ãªã„ã€‚',
      ].join('\n')
    : [
        '',
        'ã€Iã£ã½ã„æ–‡ä½“ï¼ˆè‡ªç”±ï¼‰ã€‘',
        'å¿…è¦ãªã‚‰çŸ­ã„è¨€ã„åˆ‡ã‚Šã‚’1ã¤ç½®ã„ã¦ã‚ˆã„ãŒã€æŠ¼ã—åˆ‡ã‚‰ãªã„ã€‚',
      ].join('\n');

  return base + flagshipHardNo + bandInfo + directTaskRule + lockRule + iStyleRule;
}

// âœ… internal packï¼ˆéœ²å‡ºç¦æ­¢ã®æƒ…å ±ã‚’ system ã§æ¸¡ã™ï¼‰
// ç½®ãæ›ãˆï¼šbuildInternalPackText ã® return æ–‡å­—åˆ—ã« â€œOBS CARDâ€ ã‚’è¿½åŠ 
function buildInternalPackText(args: {
  metaText?: string | null;
  historyText?: string | null;
  seedDraftHint?: string | null;
  lastTurnsCount?: number | null;
  directTask?: boolean | null;
  inputKind?: string | null;
  itOk?: boolean | null;
  intentBand?: string | null;
  tLayerHint?: string | null;

  // â˜…è¿½åŠ ï¼šæ§‹é€ å´ã®è¦³æ¸¬ï¼ˆã‚ã‚Œã°ï¼‰
  onePointText?: string | null;         // ONE_POINT slotï¼ˆæœ€å„ªå…ˆï¼‰
  situationSummary?: string | null;     // MemoryState ç”±æ¥ï¼ˆä¿é™ºï¼‰
  depthStage?: string | null;           // C1 ç­‰
  phase?: string | null;                // Inner/Outer
  qCode?: string | null;                // Q2 ç­‰
}) {
  const obsOnePoint = String(args.onePointText ?? '').trim();
  const obsSummary = String(args.situationSummary ?? '').trim();

  // â€œç‰¹å®šâ€ã®ææ–™ã¯ 1ã¤ã«çµã‚‹ï¼ˆå„ªå…ˆåº¦ï¼šONE_POINT > summaryï¼‰
  const obsPick =
    obsOnePoint.length >= 6 ? obsOnePoint :
    obsSummary.length >= 6 ? obsSummary :
    '';

    const obsCard = [
      'ã€è¦³æ¸¬ãƒ«ãƒ¼ãƒ«ï¼ˆé‡è¦ / èƒŒæ™¯ç¦æ­¢ï¼‰ã€‘',
      '- obsPick ã¯ã€Œã“ã®ã‚¿ãƒ¼ãƒ³ã® userText / seedDraft / ONE_POINT ã‹ã‚‰å–ã‚ŒãŸè¦³æ¸¬ã€ã ã‘ã€‚',
      '- é•·æœŸå±¥æ­´ãƒ»Qé·ç§»ãƒ»æ·±åº¦ãƒ»IT/Tãƒ»Anchorãƒ»RETURN ç­‰ã®â€œèƒŒæ™¯â€ã¯ã“ã“ã§ã¯ä½¿ã‚ãªã„ï¼ˆæ··ãœãªã„ï¼‰ã€‚',
      '',
      `obsOnePoint=${obsOnePoint || '(none)'}`,
      `obsSummary=${obsSummary || '(none)'}`,
      `obsPick=${obsPick || '(none)'}`,
      '',
      'ã€obsPick ã®æ‰±ã„ã€‘',
      '- obsPick ã¯ â€œæ¨æ¸¬â€ ã§ã¯ãªãã€Œç™ºè©±ã«å«ã¾ã‚Œã¦ã„ã‚‹äº‹å®Ÿï¼ˆè¦³æ¸¬ï¼‰ã€ã¨ã—ã¦ã€ãã®ã¾ã¾æœ¬æ–‡ã«ä½¿ã†ã€‚',
      '- å‡ºåŠ›æœ¬æ–‡ã®å†’é ­ã€œä¸­ç›¤ã«ã€obsPick ã®èªå½™ã‚’å«ã‚€ã€Œè¨€ã„åˆ‡ã‚Šã®1æ–‡ã€ã‚’å¿…ãšå…¥ã‚Œã‚‹ã€‚',
      '',
      'ã€ç¦æ­¢ï¼ˆå¤±æ•—åˆ¤å®šï¼‰ã€‘',
      '- æ¨é‡èªï¼ˆã‹ã‚‚ã—ã‚Œã¾ã›ã‚“/ã€œã¨æ€ã„ã¾ã™/ã€œã§ã—ã‚‡ã†/ã€œã‹ã‚‚/ã‚‚ã—/å¯èƒ½æ€§ï¼‰ã§ obsPick ã‚’æ¿ã•ãªã„ã€‚',
      '',
      'ã€è¦³æ¸¬ãŒç„¡ã„å ´åˆã€‘',
      '- è¦³æ¸¬ãŒç„¡ã„å ´åˆã®ã¿ã€Œä»®ç½®ãã€ã¨ã—ã¦çŸ­ãç•™ã‚ã‚‹ï¼ˆæ¨é‡ã§åŸ‹ã‚ãªã„ï¼‰ã€‚',
    ].join('\n');


  return [
    'INTERNAL PACK (DO NOT OUTPUT):',
    '',
    `lastTurnsCount=${args.lastTurnsCount ?? 0}`,
    `directTask=${String(args.directTask ?? false)}`,
    `inputKind=${args.inputKind ?? '(null)'}`,
    `itOk=${String(args.itOk ?? false)}`,
    `intentBand=${args.intentBand ?? '(null)'}`,
    `tLayerHint=${args.tLayerHint ?? '(null)'}`,
    '',
    'HISTORY_HINT (DO NOT OUTPUT):',
    args.historyText || '(none)',
    '',
    'SEED DRAFT HINT (DO NOT OUTPUT):',
    args.seedDraftHint || '(none)',
    obsCard,
  ].join('\n');
}


// ---------------------------------------------
// FINALç”¨ï¼šslotã‚’ä¿ã£ãŸã¾ã¾ â€œä¼šè©±æœ¬æ–‡â€ ã‚’ä½œã‚‹
// ---------------------------------------------
export async function rephraseSlotsFinal(
  extracted: ExtractedSlots,
  opts: RephraseOptions,
): Promise<RephraseResult> {
  // âœ… traceId ã‚’ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ç¢ºå®šï¼ˆçµ±ä¸€ï¼‰
  const debug = ensureDebugFinal(opts.debug);

  if (!extracted) {
    logRephraseOk(debug, [], '', 'NO_SLOTS');
    return { ok: false, reason: 'NO_SLOTS', meta: { inKeys: [], rawLen: 0, rawHead: '' } };
  }

  const enabled = envFlagEnabled(process.env.IROS_REPHRASE_FINAL_ENABLED, true);
  console.log('[IROS/REPHRASE_FLAG]', { raw: process.env.IROS_REPHRASE_FINAL_ENABLED, enabled });

  if (!enabled) {
    logRephraseOk(debug, extracted.keys, '', 'DISABLED');
    return {
      ok: false,
      reason: 'REPHRASE_DISABLED_BY_ENV',
      meta: { inKeys: extracted.keys, rawLen: 0, rawHead: '' },
    };
  }

  const mode = String(process.env.IROS_REPHRASE_FINAL_MODE ?? 'LLM').trim().toUpperCase();

  const maxLines =
    Number(process.env.IROS_REPHRASE_FINAL_MAXLINES) > 0
      ? Math.floor(Number(process.env.IROS_REPHRASE_FINAL_MAXLINES))
      : Math.max(4, Math.min(12, Math.floor(opts.maxLinesHint ?? 8)));

  const inKeys = extracted.keys;

  // (A) FIXED
  if (mode === 'FIXED') {
    const fixedTexts = buildFixedBoxTexts(inKeys.length);
    const out: Slot[] = inKeys.map((k, i) => ({
      key: k,
      text: fixedTexts[i] ?? 'ã“ã“ã§æ­¢ã‚ã‚‹ã€‚',
    }));

    logRephraseOk(debug, out.map((x) => x.key), out[0]?.text ?? '', 'FIXED');
    logRephraseAfterAttach(debug, out.map((x) => x.key), out[0]?.text ?? '', 'FIXED');

    return {
      ok: true,
      slots: out,
      meta: { inKeys, outKeys: out.map((x) => x.key), rawLen: 0, rawHead: '' },
    };
  }

  // (B) LLM
  const userText = norm(opts?.userText ?? '');
  const metaText = safeContextToText(opts?.userContext ?? null);

  const inputKindFromCtx = extractInputKindFromContext(opts?.userContext ?? null);
  const inputKindFromMeta = extractInputKindFromMetaText(metaText);
  const inputKind = inputKindFromCtx ?? inputKindFromMeta;

  const isDirectTask = extractDirectTask(userText, inputKind);

  const historyText = extractHistoryTextFromContext(opts?.userContext ?? null);
  const lastTurns = extractLastTurnsFromContext(opts?.userContext ?? null);

  // slotç”±æ¥ã®ä¸‹æ›¸ãï¼ˆéœ²å‡ºç¦æ­¢ï¼‰
  const seedDraftRaw = extracted.slots.map((s) => s.text).filter(Boolean).join('\n');

  // recall-guard ã® â€œå¿…é ˆæ–‡å­—åˆ—â€ ã‚’ seedDraft ã‹ã‚‰æŠ½å‡ºã—ã¦ system ã«å¼·åˆ¶ã™ã‚‹
  const recallMust = extractRecallMustIncludeFromSeed(seedDraftRaw);
  const mustIncludeRuleText = buildMustIncludeRuleText(recallMust);

  // ILINEæŠ½å‡ºï¼šslot + userText ä¸¡æ–¹ã‹ã‚‰æ‹¾ã†
  const lockSourceRaw = [seedDraftRaw, userText].filter(Boolean).join('\n');
  const { locked: lockedFromAll } = extractLockedILines(lockSourceRaw);

  // LLMã«æ¸¡ã™ç´ æã¯ slot ç”±æ¥ã®ã¿ï¼ˆé‡è¤‡/äºŒé‡åŒ–é˜²æ­¢ï¼‰
  const { cleanedForModel: seedDraft } = extractLockedILines(seedDraftRaw);

  const lockedILines = Array.from(new Set(lockedFromAll));

  const seedDraftHint = adaptSeedDraftHintForWriter(seedDraft, isDirectTask);

  const itOk = readItOkFromContext(opts?.userContext ?? null);
  const band = extractIntentBandFromContext(opts?.userContext ?? null);

  // lastTurns ã¯ã€Œassistantã§çµ‚ã‚ã‚‹ã€å½¢ã«æ­£è¦åŒ–ï¼ˆæœ«å°¾userã‚’è½ã¨ã™ï¼‰
  const lastTurnsSafe = (() => {
    const t = Array.isArray(lastTurns) ? [...lastTurns] : [];
    while (t.length > 0 && t[t.length - 1]?.role === 'user') t.pop();
    return t;
  })();

  const messages: Array<{ role: 'system' | 'user' | 'assistant'; content: string }> = [
    {
      role: 'system',
      content:
        systemPromptForFullReply({
          directTask: isDirectTask,
          itOk,
          band,
          lockedILines,
        }) + mustIncludeRuleText,
    },
    {
      role: 'system',
      content: buildInternalPackText({
        metaText,
        historyText,
        seedDraftHint,
        lastTurnsCount: lastTurnsSafe.length,
        itOk,
        directTask: isDirectTask,
        inputKind,
        // â€» ã“ã“ã« band / lockedCount ã‚’è¶³ã™ãªã‚‰ã€buildInternalPackText ã®å¼•æ•°å‹ã‚‚æ‹¡å¼µãŒå¿…è¦
        // band,
        // lockedCount: lockedILines.length,
      }),
    },
    ...(seedDraft
      ? [
          {
            role: 'system' as const,
            content: `ã€å†…éƒ¨ç´ æï¼šä¸‹æ›¸ãï¼ˆéœ²å‡ºç¦æ­¢ï¼‰ã€‘\n${seedDraft}`,
          },
        ]
      : []),
    ...(lastTurnsSafe as Array<{ role: 'user' | 'assistant'; content: string }>),
    { role: 'user', content: userText || 'ï¼ˆç©ºï¼‰' },
  ];

  console.log('[IROS/rephraseEngine][MSG_PACK]', {
    traceId: debug.traceId,
    conversationId: debug.conversationId,
    userCode: debug.userCode,
    lastTurns: lastTurnsSafe.length,
    hasHistoryText: Boolean(historyText),
    msgCount: messages.length,
    roles: messages.map((m) => m.role),
    msgHeads: messages.map((m, i) => ({
      i,
      role: m.role,
      len: String(m.content ?? '').length,
      head: safeHead(String(m.content ?? ''), 120),
    })),
    seedDraftLen: seedDraft.length,
    seedDraftHead: safeHead(seedDraft, 120),
    itOk,
    intentBand: band.intentBand,
    tLayerHint: band.tLayerHint,
    directTask: isDirectTask,
    inputKind,
    inputKindFromMeta,
    inputKindFromCtx,
    lockedILines: lockedILines.length,
  });

  // ---------------------------------------------
  // LLM call
  // ---------------------------------------------
  let raw = '';
  try {
    raw = await chatComplete({
      purpose: 'reply',
      model: opts.model,
      temperature: typeof opts.temperature === 'number' ? opts.temperature : 0.2,
      max_tokens: 700,
      messages,
      extraBody: { __flagship_pass: 1 },
      traceId: debug.traceId,
      conversationId: debug.conversationId,
      userCode: debug.userCode,
      trace: { traceId: debug.traceId, conversationId: debug.conversationId, userCode: debug.userCode },
      audit: {
        slotPlanPolicy: 'FINAL',
        mode: (debug as any)?.mode ?? null,
        qCode: (debug as any)?.qCode ?? null,
        depthStage: (debug as any)?.depthStage ?? null,
      },
    } as any);
  } catch (e: any) {
    console.error('[IROS/REPHRASE_FINAL][LLM] failed', {
      traceId: debug.traceId,
      conversationId: debug.conversationId,
      userCode: debug.userCode,
      message: String(e?.message ?? e),
    });
    logRephraseOk(debug, extracted.keys, '', 'LLM_FAIL');
    return { ok: false, reason: 'LLM_CALL_FAILED', meta: { inKeys, rawLen: 0, rawHead: '' } };
  }

  logRephraseOk(debug, extracted.keys, raw, 'LLM');

  // å†…éƒ¨ãƒ©ãƒ™ãƒ«ç­‰ãŒæ··å…¥ã—ãŸã‚‰ç ´æ£„ï¼ˆéœ²å‡ºç¦æ­¢ï¼‰
  if (containsForbiddenLeakText(raw)) {
    logRephraseOk(debug, extracted.keys, raw, 'INTERNAL_MARKER_LEAKED');
    return {
      ok: false,
      reason: 'INTERNAL_MARKER_LEAKED',
      meta: { inKeys, rawLen: String(raw ?? '').length, rawHead: safeHead(String(raw ?? ''), 80) },
    };
  }

  // ILINEæ”¹å¤‰ç¦æ­¢
  const iLineOk = verifyLockedILinesPreserved(raw, lockedILines);
  console.log('[IROS/REPHRASE][VERIFY]', {
    traceId: debug.traceId,
    conversationId: debug.conversationId,
    userCode: debug.userCode,
    iLine_preserved: iLineOk,
    lockedCount: lockedILines.length,
  });

  if (!iLineOk) {
    return {
      ok: false,
      reason: 'ILINE_NOT_PRESERVED',
      meta: { inKeys, rawLen: String(raw ?? '').length, rawHead: safeHead(String(raw ?? ''), 80) },
    };
  }

  // recall-guard hardï¼ˆè½ã¡ãŸã‚‰ç ´æ£„ï¼‰
  {
    const recallCheck = recallGuardOk({
      slotKeys: inKeys,
      slotsForGuard: (extracted?.slots ?? null) as any,
      llmOut: raw,
    });

    console.log('[IROS/REPHRASE][RECALL_GUARD]', {
      traceId: debug.traceId,
      conversationId: debug.conversationId,
      userCode: debug.userCode,
      enforced: shouldEnforceRecallGuard(inKeys),
      ok: recallCheck.ok,
      missing: recallCheck.missing,
      needles: recallCheck.needles,
    });

    if (!recallCheck.ok) {
      console.warn('[IROS/REPHRASE][RECALL_GUARD_REJECT]', {
        traceId: debug.traceId,
        conversationId: debug.conversationId,
        userCode: debug.userCode,
        missing: recallCheck.missing,
        needles: recallCheck.needles,
        outHead: normLiteForLog(raw).slice(0, 120),
      });

      return {
        ok: false,
        reason: 'RECALL_GUARD_REJECT',
        meta: { inKeys, rawLen: String(raw ?? '').length, rawHead: safeHead(String(raw ?? ''), 80) },
      };
    }
  }

  // ---------------------------------------------
  // âœ… ONE_POINT scaffold: å…ˆã« â€œå¾©å…ƒè¾¼ã¿â€ ã§ raw ã‚’æ•´ãˆã‚‹
  // ---------------------------------------------
  const slotsForGuard = (extracted?.slots ?? null) as any;
  const scaffoldActive = isScaffoldActive(slotsForGuard);

  let rawGuarded = raw;
  let scaffoldMissingAfterRestore: string[] = [];

  if (scaffoldActive) {
    // âœ… å‰ã‚¿ãƒ¼ãƒ³ã®æ®‹ç•™ã‚’æ½°ã™ï¼ˆmh1/mh2 ãŒ OK ãªã‚‰å¿…ãšç©ºã«æˆ»ã™ï¼‰
    scaffoldMissingAfterRestore = [];

    const onePointFix = ensureOnePointInOutput({ slotsForGuard, llmOut: rawGuarded });

    console.log('[IROS/REPHRASE][ONE_POINT_GUARD]', {
      traceId: debug.traceId,
      conversationId: debug.conversationId,
      userCode: debug.userCode,
      ok: onePointFix.ok,
      missing: onePointFix.missing,
      hasOnePoint: Boolean(onePointFix.needles.onePoint),
      source: onePointFix.needles.source,
    });

    if (!onePointFix.ok) {
      return {
        ok: false,
        reason: 'ONE_POINT_GUARD_REJECT',
        meta: { inKeys, rawLen: String(rawGuarded ?? '').length, rawHead: safeHead(String(rawGuarded ?? ''), 80) },
      };
    }

    rawGuarded = onePointFix.out;

    // must-haveï¼ˆpurpose / points3 / axesï¼‰
    // âœ… scaffoldä¸­ã¯ã€Œæœ¬æ–‡â†’åˆ¤å®šâ†’å¾©å…ƒã€ã§ã¯ãªãã€
    // ã€Œæ§‹é€ ã§å¾©å…ƒï¼ˆidempotentï¼‰â†’ ãã®çµæœã‚’â€œæœ€åˆã®åˆ¤å®šãƒ­ã‚°â€ã¨ã—ã¦å‡ºã™ã€ã«çµ±ä¸€ã™ã‚‹ã€‚
    {
      // 1) æ¬ è½ã‚’æŠ½å‡º
      const mh0 = scaffoldMustHaveOk({
        slotKeys: inKeys,
        slotsForGuard,
        llmOut: rawGuarded,
      });

      // 2) æ¬ è½ãŒã‚ã‚Œã°æ§‹é€ ã§å¾©å…ƒï¼ˆç›®çš„ï¼šæœ€åˆã®åˆ¤å®šã§OKã«å¯„ã›ã‚‹ï¼‰
      if (!mh0.ok) {
        rawGuarded = restoreScaffoldMustHaveInOutput({
          llmOut: rawGuarded,
          slotsForGuard,
          missing: mh0.missing,
        });
      }

      // 3) å¾©å…ƒå¾Œã‚’â€œå”¯ä¸€ã®must-haveåˆ¤å®šâ€ã¨ã—ã¦æ¡ç”¨ã—ãƒ­ã‚°ã‚’å‡ºã™
      const mh1 = scaffoldMustHaveOk({
        slotKeys: inKeys,
        slotsForGuard,
        llmOut: rawGuarded,
      });

      console.log('[IROS/REPHRASE][SCAFFOLD_MUST_HAVE]', {
        traceId: debug.traceId,
        conversationId: debug.conversationId,
        userCode: debug.userCode,
        ok: mh1.ok,
        missing: mh1.missing,
        note: mh0.ok ? 'NO_RESTORE_NEEDED' : 'RESTORED_BEFORE_CHECK',
      });

      // 4) å¾©å…ƒã—ã¦ã‚‚ãƒ€ãƒ¡ãªã‚‰ã€å¾Œæ®µã§ seedFromSlots ã«æˆ»ã™ãŸã‚ã«æ®‹ã™
      scaffoldMissingAfterRestore = mh1.ok ? [] : mh1.missing;
    }
  }


  // ---------------------------------------------
  // Flagship Guardï¼ˆæ¡ç”¨ã‚²ãƒ¼ãƒˆï¼‰
  // ---------------------------------------------
  const guardEnabled = envFlagEnabled(process.env.IROS_FLAGSHIP_GUARD_ENABLED, true);
  const renderEngine = Boolean(debug.renderEngine ?? true);

  // âœ… candidate ã¯ â€œã‚¬ãƒ¼ãƒ‰å¾Œæœ¬æ–‡â€ ã‚’ä½¿ã†
  // ãŸã ã— scaffoldï¼ˆONE_POINT packï¼‰ä¸­ã¯ã€clampLines ãŒ must-have ã‚’åˆ‡ã‚Šè½ã¨ã—ã¦
  // æ——å°ï¼ˆæ§‹é€ ï¼‰ãŒå£Šã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€clamp å¾Œã«æ§‹é€ ã§å¾©å…ƒã—ã¦ã‹ã‚‰ç¢ºå®šã™ã‚‹ã€‚
  let candidateRaw = clampLines(rawGuarded, maxLines);
  let candidate = finalizeLamp(candidateRaw, renderEngine);

  // âœ… scaffoldæ™‚ï¼šclampå¾Œã« must-have ãŒå£Šã‚Œã¦ã„ãŸã‚‰ã€æ§‹é€ ã§å¾©å…ƒâ†’å†clamp
  if (scaffoldActive && candidate && slotsForGuard) {
    const mhAfterClamp = scaffoldMustHaveOk({
      slotKeys: inKeys,
      slotsForGuard,
      llmOut: candidate,
    });

    if (!mhAfterClamp.ok) {
      const restoredAfterClamp = restoreScaffoldMustHaveInOutput({
        llmOut: candidate,
        slotsForGuard,
        missing: mhAfterClamp.missing,
      });

      candidateRaw = clampLines(restoredAfterClamp, maxLines);
      candidate = finalizeLamp(candidateRaw, renderEngine);
    }
  }


  if (!candidate) {
    logRephraseOk(debug, extracted.keys, '', 'LLM_EMPTY_AFTER_CLAMP');
    return { ok: false, reason: 'LLM_EMPTY', meta: { inKeys, rawLen: 0, rawHead: '' } };
  }

  if (containsForbiddenLeakText(candidate)) {
    logRephraseOk(debug, extracted.keys, candidate, 'FINAL_LEAKED');
    return {
      ok: false,
      reason: 'FINAL_LEAKED',
      meta: { inKeys, rawLen: candidate.length, rawHead: safeHead(candidate, 80) },
    };
  }

  // seedï¼ˆslotç”±æ¥ï¼‰ã¸æˆ»ã™ãŸã‚ã®æº–å‚™
  const seedFromSlotsRaw = (extracted?.slots ?? [])
    .map((s: any) => String(s?.text ?? ''))
    .filter((s: string) => s.trim())
    .join('\n');
  const seedFromSlots = seedFromSlotsRaw ? finalizeLamp(clampLines(seedFromSlotsRaw, maxLines), renderEngine) : '';

  // âœ… scaffold must-have ãŒæœ€å¾Œã¾ã§æº€ãŸã›ãªã„ãªã‚‰ seedFromSlots ã«æˆ»ã™ï¼ˆPDFæ‰‹é †ï¼‰
  if (scaffoldActive && scaffoldMissingAfterRestore.length > 0 && seedFromSlots) {
    console.warn('[IROS/REPHRASE][SCAFFOLD_MUST_HAVE_TO_SEED]', {
      traceId: debug.traceId,
      conversationId: debug.conversationId,
      userCode: debug.userCode,
      missing: scaffoldMissingAfterRestore,
    });
    const outSlots = buildSlotsWithFirstText(inKeys, seedFromSlots);
    logRephraseAfterAttach(debug, inKeys, outSlots[0]?.text ?? '', 'SCAFFOLD_TO_SEED');
    return {
      ok: true,
      slots: outSlots,
      meta: {
        inKeys,
        outKeys: outSlots.map((x) => x.key),
        rawLen: seedFromSlots.length,
        rawHead: safeHead(seedFromSlots, 80),
        note: 'SCAFFOLD_TO_SEED',
        extra: {
          scaffoldMissing: scaffoldMissingAfterRestore,
        },
      },
    };
  }

  // WARNè–„é€ƒã’ã‚’ seed ã¸æˆ»ã™ï¼ˆFLAG_* ã¨ STABILIZE pack ã ã‘å³ã—ã‚ï¼‰
  const isFlagReplyLike = Array.isArray(inKeys) && inKeys.every((k) => String(k).startsWith('FLAG_'));
  const isStabilizePack =
    Array.isArray(inKeys) && inKeys.includes('OBS') && inKeys.includes('SHIFT') && inKeys.includes('NEXT');

  // âœ… WARNè–„é€ƒã’ã‚’ seed ã¸æˆ»ã™ï¼ˆFLAG_* ã¨ STABILIZE pack ã ã‘å³ã—ã‚ï¼‰
  // - scaffoldï¼ˆONE_POINTï¼‰ä¸­ã¯ WARN ã§ã¯ seed ã«æˆ»ã•ãªã„ï¼ˆmust-have ã¯ scaffoldå´ã§æ‹…ä¿ã™ã‚‹ï¼‰
  const shouldRejectWarnToSeed = (verdict: any) => {
    if (scaffoldActive) return false;

    const level = String(verdict?.level ?? '').toUpperCase();
    if (level !== 'WARN') return false;

    const reasons = new Set((verdict?.reasons ?? []).map((x: any) => String(x)));
    const genericBad = reasons.has('GENERIC_MANY') || reasons.has('GENERIC_PRESENT');
    const hedgeBad = reasons.has('HEDGE_PRESENT') || reasons.has('HEDGE_MANY');
    const cheerBad = reasons.has('CHEER_PRESENT') || reasons.has('CHEER_MANY');

    // âœ… flagReplyã¯â€œè–„ã„å‹â€ãŒå‡ºãŸã‚‰å³seedã¸æˆ»ã™ï¼ˆå…¥åŠ›å´ã‚’å¼·ãã™ã‚‹ï¼‰
    if (isFlagReplyLike) return genericBad || hedgeBad || cheerBad;

    // âœ… stabilize pack ã¯å¾“æ¥é€šã‚Šå³ã—ã‚ï¼ˆgeneric + (hedge|cheer) ã®ã¨ãã ã‘æˆ»ã™ï¼‰
    if (isStabilizePack) return genericBad && (hedgeBad || cheerBad);

    return false;
  };



// verdict ä¿æŒï¼ˆmeta.extra ã«é‹ã¶ï¼‰
let lastFlagshipVerdict: any = null;
let lastFlagshipHead: string | null = null;

const runFlagship = (text: string) => {
  let v = flagshipGuard(String(text ?? ''), {
    slotKeys: Array.isArray(inKeys) ? inKeys : null,
    slotsForGuard: Array.isArray(slotsForGuard) ? slotsForGuard : null,
  });

  // âœ… scaffoldä¸­ã¯ã€Œmust-have ã®æœ€çµ‚åˆ¤å®šã€ã‚’æ§‹é€ ï¼ˆslotsï¼‰å´ã«çµ±ä¸€ã™ã‚‹
  // - flagshipGuard ã¯æœ¬æ–‡ã ã‘ã§åˆ¤å®šã™ã‚‹ãŸã‚ã€å¾©å…ƒæ¸ˆã¿ã§ã‚‚ scaffoldç³» missing ã‚’å‡ºã—å¾—ã‚‹ï¼ˆä¸æ•´åˆï¼‰
  // - ã“ã“ã§ â€œæ§‹é€ ãƒã‚§ãƒƒã‚¯OKãªã‚‰ scaffoldç³»ã®æ¬ è½ç†ç”±ã‚’ç„¡åŠ¹åŒ–â€ ã—ã¦ verdict ã‚’æ•´ãˆã‚‹
  if (scaffoldActive && Array.isArray(slotsForGuard)) {
    const mhFinal = scaffoldMustHaveOk({
      slotKeys: inKeys,
      slotsForGuard,
      llmOut: String(text ?? ''),
    });

    if (mhFinal.ok) {
      const drop = new Set([
        // æ—§scaffoldç†ç”±
        'SCAFFOLD_PURPOSE_MISSING',
        'SCAFFOLD_ONE_POINT_MISSING',
        'SCAFFOLD_POINTS3_NOT_PRESERVED',
        'SCAFFOLD_MUST_HAVE_BROKEN',
        // æ–°scaffoldç†ç”±ï¼ˆæ„å‘³æ¤œå‡ºï¼‰
        'SCAFFOLD_NEED_FRAME',
        'SCAFFOLD_NEED_ONE_POINT',
        'SCAFFOLD_NEED_AXES',
      ]);

      const reasons0 = Array.isArray((v as any)?.reasons) ? (v as any).reasons : [];
      const reasons1 = reasons0.filter((r: any) => !drop.has(String(r)));
      const removed = reasons1.length !== reasons0.length;

      const level0 = String((v as any)?.level ?? '').toUpperCase();

      // scaffoldç†ç”±ã—ã‹ç„¡ã‹ã£ãŸãªã‚‰ FATAL ã‚’è½ã¨ã™ï¼ˆæœ€å°ä¿®æ­£ï¼‰
      if (level0 === 'FATAL' && removed && reasons1.length === 0) {
        const warn = Number((v as any)?.score?.warn ?? 0);
        const nextLevel = warn >= 3 ? 'WARN' : 'OK';

        v = {
          ...(v as any),
          level: nextLevel,
          ok: true,
          reasons: [],
          score: { ...((v as any)?.score ?? {}), fatal: 0 },
          shouldRaiseFlag: false,
        } as any;
      } else if (removed) {
        // FATALä»¥å¤–ã§ã‚‚ scaffoldç†ç”±ã ã‘è½ã¨ã—ã¦ reasons ã‚’æ•´ãˆã‚‹
        v = {
          ...(v as any),
          reasons: reasons1,
        } as any;
      }
    }
  }

  lastFlagshipVerdict = {
    level: (v as any).level,
    ok: (v as any).ok,
    qCount: (v as any).qCount,
    score: (v as any).score,
    reasons: Array.isArray((v as any).reasons) ? (v as any).reasons : [],
  };
  lastFlagshipHead = safeHead(String(text ?? ''), 220);

  console.log('[IROS/FLAGSHIP][VERDICT]', {
    traceId: debug.traceId,
    conversationId: debug.conversationId,
    userCode: debug.userCode,
    level: (v as any).level,
    ok: (v as any).ok,
    qCount: (v as any).qCount,
    score: (v as any).score,
    reasons: (v as any).reasons,
    head: lastFlagshipHead,
  });

  return v;
};




  const adoptAsSlots = (text: string, note?: string): RephraseResult => {
    const outSlots = buildSlotsWithFirstText(inKeys, text);

    const raiseIn = readShouldRaiseFlagFromContext(opts?.userContext ?? null);
    const extra: any = {};

    if (raiseIn.on === true) {
      extra.shouldRaiseFlag = true;
      extra.flagReasons = raiseIn.reason ? [raiseIn.reason] : [];
    }

    if (lastFlagshipVerdict) {
      extra.flagshipVerdict = lastFlagshipVerdict;
      if (lastFlagshipHead) extra.flagshipHead = lastFlagshipHead;
    } else {
      extra.flagshipVerdict = { level: null, ok: null, reasons: [] as string[], score: null };
    }

    // scaffoldæƒ…å ±ï¼ˆã‚ã‚Œã°ï¼‰
    if (scaffoldActive) extra.scaffoldActive = true;

    logRephraseAfterAttach(debug, inKeys, outSlots[0]?.text ?? '', note ?? 'LLM');

    return {
      ok: true,
      slots: outSlots,
      meta: {
        inKeys,
        outKeys: outSlots.map((x) => x.key),
        rawLen: String(text ?? '').length,
        rawHead: safeHead(String(text ?? ''), 80),
        note,
        extra,
      },
    };
  };

  if (!guardEnabled) {
    return adoptAsSlots(candidate, 'FLAGSHIP_DISABLED');
  }

  // ------------------------
  // æ¡ç”¨åˆ¤å®š
  // ------------------------
  let v = runFlagship(candidate);

  // âœ… ONE_POINT scaffold ã®ã¨ãã ã‘ï¼š
  // â€œèƒŒæ™¯ã‚’ä½¿ã‚ãšã«ã€æ–­å®šã ã‘ã‚’æ­£ã™â€ ãŸã‚ã®æœ€å°ä»‹å…¥
  // - HEDGE_PRESENT ã§ FATAL â†’ LLMå†ç”Ÿæˆã«è¡Œãå‰ã«ã€Œæ–­å®šã€ã¸å¯„ã›ã‚‹
  // - æ–°ã—ã„æ„å‘³ã¯è¶³ã•ãªã„ï¼ˆèªå°¾ã ã‘ä¿®æ­£ / 1æ–‡ã ã‘å·®ã—æˆ»ã—ï¼‰
  const isOnePointScaffold =
    scaffoldActive && isFlagReplyLike && Array.isArray(inKeys) && inKeys.some((k) => String(k) === 'FLAG_ONE_POINT_1');

  const hasHedgeReason = (verdict: any) => {
    const reasons = Array.isArray(verdict?.reasons) ? verdict.reasons.map((x: any) => String(x)) : [];
    return reasons.includes('HEDGE_PRESENT') || reasons.includes('HEDGE_MANY');
  };

  const stripHedgePhrasesLite = (text: string) => {
    let s = String(text ?? '');

    // 1) â€œã€œã‹ã‚‚ã—ã‚Œã¾ã›ã‚“/ã€œã‹ã‚‚/ã‚‚ã—ã‹ã—ãŸã‚‰â€ ã‚’è½ã¨ã™ï¼ˆæ„å‘³ã¯å¢—ã‚„ã•ãªã„ï¼‰
    s = s.replace(/(ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“|ã‹ã‚‚|ã‚‚ã—ã‹ã—ãŸã‚‰)/g, '');

    // 2) â€œã€œã¨æ€ã„ã¾ã™/ã§ã—ã‚‡ã†/æ°—ãŒã—ã¾ã™â€ ãªã©ã®æ¨é‡èªå°¾ã‚’å¼±ã‚ã‚‹ï¼ˆé›‘ã«æ¶ˆã•ãªã„ï¼‰
    s = s.replace(/(ã¨æ€ã„ã¾ã™|ã§ã—ã‚‡ã†|æ°—ãŒã—ã¾ã™)/g, '');

    // 3) é€£ç¶šç©ºè¡Œã‚’æ•´ãˆã‚‹
    s = s.replace(/\n{3,}/g, '\n\n');

    return s.trim();
  };

  const replaceFirstSentence = (text: string, newFirstLine: string) => {
    const t = String(text ?? '').trim();
    const one = String(newFirstLine ?? '').trim();
    if (!t || !one) return t;

    // å…ˆé ­1æ–‡ï¼ˆæœ€åˆã®æ”¹è¡Œ or å¥ç‚¹ï¼‰ã‚’ç½®æ›
    const m = t.match(/^(.+?)(\n|ã€‚|ï¼|ï¼Ÿ)/);
    if (!m) return one + '\n' + t;

    const head = m[0];
    const rest = t.slice(head.length).trimStart();
    return (one + '\n' + rest).trim();
  };

  if (guardEnabled && isOnePointScaffold && v && String(v.level ?? '').toUpperCase() === 'FATAL' && hasHedgeReason(v)) {
    // ã¾ãš â€œONE_POINT ã®1æ–‡â€ ã‚’ seed ã‹ã‚‰å–ã‚Šå‡ºã™ï¼ˆæœ€ã‚‚å®‰å…¨ï¼šæ„å‘³ã‚’å¢—ã‚„ã•ãªã„ï¼‰
    const onePointSeed =
      Array.isArray(slotsForGuard)
        ? String((slotsForGuard as any[]).find((s: any) => String(s?.key ?? '') === 'FLAG_ONE_POINT_1')?.text ?? '').trim()
        : '';

    let fixed = String(candidate ?? '');

    // â‘  å…ˆé ­1æ–‡ã ã‘ ONE_POINT ã«å·®ã—æˆ»ã™ï¼ˆã‚‚ã— seed ãŒå–ã‚ŒãŸã‚‰æœ€å„ªå…ˆï¼‰
    if (onePointSeed) fixed = replaceFirstSentence(fixed, onePointSeed);

    // â‘¡ ãã‚Œã§ã‚‚æ®‹ã‚‹æ¨é‡èªã‚’è»½ãå‰¥ãŒã™ï¼ˆæ„å‘³ã¯å¢—ã‚„ã•ãªã„ï¼‰
    fixed = stripHedgePhrasesLite(fixed);

    // clamp / lamp ã¯ â€œcandidateã¨åŒã˜çµŒè·¯â€ ã«ãã‚ãˆã‚‹
    fixed = finalizeLamp(clampLines(fixed, maxLines), renderEngine);

    // ã‚‚ã†ä¸€å› verdictï¼ˆã“ã‚Œã§é€šã‚Œã° retry ã«è¡Œã‹ãªã„ï¼‰
    const vFixed = runFlagship(fixed);
    if (vFixed?.ok) return adoptAsSlots(fixed, 'FLAGSHIP_HEDGE_FIXED_ONE_POINT');
  }


  // âœ… ä¸Šä½ã‹ã‚‰ã®â€œä»‹å…¥è¦æ±‚â€ãŒç«‹ã£ã¦ã„ã‚‹ãªã‚‰ã€OKã§ã‚‚æ¡ã‚Šæ½°ã•ãªã„
  const raise = readShouldRaiseFlagFromContext(opts?.userContext ?? null);
  const forceIntervene = raise.on === true;

  if (forceIntervene) {
    console.warn('[IROS/FLAGSHIP][FORCE_INTERVENE]', {
      traceId: debug.traceId,
      conversationId: debug.conversationId,
      userCode: debug.userCode,
      reason: raise.reason,
      verdictLevel: v.level,
      verdictReasons: v.reasons,
      head: safeHead(candidate, 160),
    });

    const reasonText = String(raise.reason ?? '');
    const isStallOrDrift = /STALL|POSITION_DRIFT/i.test(reasonText);

    // STALL/DRIFT ã¯ retry ã‚ˆã‚Š seed ã¸æˆ»ã™æ–¹ãŒ â€œæ§‹é€ ã§ç›´ã‚‹â€
    if (isStallOrDrift && seedFromSlots) {
      return adoptAsSlots(seedFromSlots, 'FLAGSHIP_RAISE_TO_SEED');
    }

    // ãã‚Œä»¥å¤–ã¯å¾“æ¥é€šã‚Š FATAL ã¨ã—ã¦ retry ã«å…¥ã‚Œã‚‹
    v = {
      ...v,
      ok: false,
      level: 'FATAL',
      reasons: Array.from(new Set([...(v.reasons ?? []), 'FORCE_INTERVENE'])),
    } as any;
  }

  // WARNè–„é€ƒã’ â†’ seedã¸æˆ»ã™ï¼ˆå¯¾è±¡ã ã‘ï¼‰
  if (v && String(v.level ?? '').toUpperCase() === 'WARN' && shouldRejectWarnToSeed(v) && seedFromSlots) {
    console.warn('[IROS/FLAGSHIP][REJECT_WARN_TO_SEED]', {
      traceId: debug.traceId,
      conversationId: debug.conversationId,
      userCode: debug.userCode,
      level: v.level,
      reasons: v.reasons,
    });
    return adoptAsSlots(seedFromSlots, 'FLAGSHIP_WARN_REJECT_TO_SEED');
  }

  // OKãªã‚‰æ¡ç”¨
  if (v?.ok) return adoptAsSlots(candidate, 'FLAGSHIP_OK');

  // ------------------------
  // FATAL â†’ 1å›ã ã‘å†ç”Ÿæˆ
  // ------------------------
  let raw2 = '';

  const retryMessages: Array<{ role: 'system' | 'user' | 'assistant'; content: string }> = [
    ...messages,
    {
      role: 'system',
      content:
        'ã€å†ç”Ÿæˆï¼ˆæ——å°ï¼‰ã€‘\n' +
        '- ç›®çš„ï¼šèª­ã¿æ‰‹ãŒâ€œè‡ªåˆ†ã§ç­”ãˆã‚’å‡ºã›ã‚‹å ´æ‰€â€ã‚’ä½œã‚‹ã€‚\n' +
        '- ã‚„ã‚‹ã“ã¨ï¼šè¦–ç‚¹/è§’åº¦/åˆ‡ã‚Šåˆ†ã‘/è¼ªéƒ­ã‚’1æ®µã ã‘æç¤ºã—ã€èª­è€…ã®è¶³å ´ã‚’ä½œã‚‹ã€‚\n' +
        '- å¿…é ˆï¼šå…¥åŠ›ï¼ˆuserText / lastTurns / historyText / seedDraftï¼‰ã«å«ã¾ã‚Œã‚‹å…·ä½“èªã‚’æœ€ä½1ã¤ã€æœ¬æ–‡ã«è‡ªç„¶ã«å…¥ã‚Œã‚‹ã€‚\n' +
        '- ç¦æ­¢ï¼šæ±ç”¨å¿œæ´ï¼ˆå¤§ä¸ˆå¤«/å¿œæ´/ãã£ã¨/ç„¦ã‚‰ãªãã¦ã„ã„/å°‘ã—ãšã¤ ç­‰ï¼‰ã€ã¼ã‹ã—ï¼ˆã‹ã‚‚ã—ã‚Œã¾ã›ã‚“/ã¨æ€ã„ã¾ã™ é€£ç™ºï¼‰ã€ç®‡æ¡æ›¸ãã€‚\n' +
        '- ç¦æ­¢ï¼šå…¥åŠ›ã«ç„¡ã„èƒŒæ™¯ã‚’æ¨æ¸¬ã§è¶³ã•ãªã„ã€‚\n' +
        '- è³ªå•ï¼š0ã€œ1å€‹ã¾ã§ï¼ˆã§ãã‚Œã°0ï¼‰ã€‚\n' +
        '- è¡Œæ•°ï¼šdirectTaskã®ãƒ«ãƒ¼ãƒ«ã«å¾“ã†ã€‚\n' +
        '- ä¼šè©±æ–‡ã®ã¿ã€‚å†…éƒ¨æƒ…å ±ã¯å‡ºã•ãªã„ã€‚',
    },
  ];

  console.log('[IROS/FLAGSHIP][RETRY]', {
    traceId: debug.traceId,
    conversationId: debug.conversationId,
    userCode: debug.userCode,
    reason: v?.reasons,
  });

  try {
    raw2 = await chatComplete({
      purpose: 'reply',
      model: opts.model,
      temperature: typeof opts.temperature === 'number' ? opts.temperature : 0.2,
      max_tokens: 700,
      messages: retryMessages,
      traceId: debug.traceId,
      conversationId: debug.conversationId,
      userCode: debug.userCode,
      trace: { traceId: debug.traceId, conversationId: debug.conversationId, userCode: debug.userCode },
      audit: {
        slotPlanPolicy: 'FINAL',
        mode: (debug as any)?.mode ?? null,
        qCode: (debug as any)?.qCode ?? null,
        depthStage: (debug as any)?.depthStage ?? null,
        note: 'FLAGSHIP_RETRY',
      },
    } as any);
  } catch (e: any) {
    console.error('[IROS/FLAGSHIP][RETRY] failed', {
      traceId: debug.traceId,
      conversationId: debug.conversationId,
      userCode: debug.userCode,
      err: e?.message ?? String(e),
    });
    raw2 = '';
  }

  // retry ã®å„ç¨®ã‚¬ãƒ¼ãƒ‰
  if (raw2 && containsForbiddenLeakText(raw2)) raw2 = '';
  if (raw2 && !verifyLockedILinesPreserved(raw2, lockedILines)) raw2 = '';
  if (raw2) {
    const recall2 = recallGuardOk({
      slotKeys: inKeys,
      slotsForGuard: (extracted?.slots ?? null) as any,
      llmOut: raw2,
    });
    if (!recall2.ok) raw2 = '';
  }

  if (raw2) {
    // âœ… retryCandidate ã‚‚ â€œã‚¬ãƒ¼ãƒ‰å¾Œæœ¬æ–‡â€ ã¨ã—ã¦æ‰±ã†ï¼ˆscaffoldä¸­ã¯ä¸€ç‚¹å¾©å…ƒâ†’must-haveå¾©å…ƒï¼‰
    let raw2Guarded = raw2;

    if (scaffoldActive) {
      const one2 = ensureOnePointInOutput({ slotsForGuard, llmOut: raw2Guarded });
      if (!one2.ok) raw2Guarded = '';
      else raw2Guarded = one2.out;

      if (raw2Guarded) {
        const mh1 = scaffoldMustHaveOk({ slotKeys: inKeys, slotsForGuard, llmOut: raw2Guarded });
        if (!mh1.ok) {
          raw2Guarded = restoreScaffoldMustHaveInOutput({ llmOut: raw2Guarded, slotsForGuard, missing: mh1.missing });
          const mh2 = scaffoldMustHaveOk({ slotKeys: inKeys, slotsForGuard, llmOut: raw2Guarded });
          if (!mh2.ok) raw2Guarded = '';
        }
      }
    }

    const retryCandidate = raw2Guarded ? finalizeLamp(clampLines(raw2Guarded, maxLines), renderEngine) : '';
    if (retryCandidate && !containsForbiddenLeakText(retryCandidate)) {
      const v2 = runFlagship(retryCandidate);

      if (v2 && String(v2.level ?? '').toUpperCase() === 'WARN' && shouldRejectWarnToSeed(v2) && seedFromSlots) {
        console.warn('[IROS/FLAGSHIP][REJECT_WARN_TO_SEED][RETRY]', {
          traceId: debug.traceId,
          conversationId: debug.conversationId,
          userCode: debug.userCode,
          level: v2.level,
          reasons: v2.reasons,
        });
        return adoptAsSlots(seedFromSlots, 'FLAGSHIP_WARN_REJECT_TO_SEED_RETRY');
      }

      if (v2?.ok) return adoptAsSlots(retryCandidate, 'FLAGSHIP_RETRY_ADOPTED');
    }
  }

  // ------------------------
  // FALLBACKï¼ˆæœ€å°ã®â€œæ——å°â€å®‰å…¨æ–‡ï¼‰
  // ------------------------
  const userTextRaw = String(opts?.userText ?? '').trim();
  const userHead = userTextRaw ? safeHead(userTextRaw, 56) : '';

  const fallback = userHead
    ? `ç›®æ¨™ã¯ã€Œ${userHead}ã€ãªã‚“ã ã­ã€‚\n\nãã®â€œå®Œæˆâ€ã‚’ã€ä»Šæ—¥ã®è¨€è‘‰ã§ä¸€æ®µã ã‘å…·ä½“åŒ–ã™ã‚‹ã¨ä½•ã«ãªã‚‹ï¼Ÿ`
    : `ç›®æ¨™ãŒã€Œå®Œæˆã€ã«å‘ã„ã¦ã„ã‚‹ã®ã¯ä¼ã‚ã£ãŸã€‚\n\nãã®â€œå®Œæˆâ€ã‚’ã€ä»Šæ—¥ã®è¨€è‘‰ã§ä¸€æ®µã ã‘å…·ä½“åŒ–ã™ã‚‹ã¨ä½•ã«ãªã‚‹ï¼Ÿ`;

  const cleanedFallback = finalizeLamp(clampLines(fallback, maxLines), renderEngine);

  if (!cleanedFallback || containsForbiddenLeakText(cleanedFallback)) {
    logRephraseOk(debug, extracted.keys, candidate, 'FLAGSHIP_FATAL_NO_FALLBACK');
    return {
      ok: false,
      reason: 'FLAGSHIP_GUARD_FATAL',
      meta: { inKeys, rawLen: candidate.length, rawHead: safeHead(candidate, 80) },
    };
  }

  console.log('[IROS/FLAGSHIP][FALLBACK_ADOPT]', {
    traceId: debug.traceId,
    conversationId: debug.conversationId,
    userCode: debug.userCode,
    reasons: v?.reasons,
    outHead: safeHead(cleanedFallback, 120),
  });

  return adoptAsSlots(cleanedFallback, 'FLAGSHIP_FALLBACK_ADOPTED');
}

/**
 * âœ… çµ¶å¯¾ãƒ«ãƒ¼ãƒ«ï¼ˆå¹»è¦š/æé€  é˜²æ­¢ï¼‰
 * - å…¥åŠ›ã«å­˜åœ¨ã—ãªã„ã€Œéå»ã®å‡ºæ¥äº‹ã€ã€Œå‰ã«è¨€ã£ã¦ãŸã€ç­‰ã‚’ä½œã‚‰ãªã„
 * - ã€Œè¦šãˆã¦ã‚‹ã€ã€Œå‰ã«è©±ã—ãŸã‚ˆã­ã€ç­‰ã®â€œè¨˜æ†¶æ–­è¨€â€ã¯ç¦æ­¢
 *   ãŸã ã—ã€å…¥åŠ›ï¼ˆhistory/messages/seedDraftï¼‰ã«æ˜ç¤ºã§å«ã¾ã‚Œã¦ã„ã‚‹ç¯„å›²ã®è¦ç´„ã¯å¯
 * - ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œè¦šãˆã¦ã‚‹ï¼Ÿã€ã¨èã„ãŸå ´åˆã¯ã€äº‹å®Ÿã®æ–­è¨€ã§ã¯ãªã
 *   ã€Œã“ã®å…¥åŠ›ã«ã‚ã‚‹é™ã‚Šã§ã¯â—¯â—¯ã€ã®ç¾åœ¨è¦ç´„ã§è¿”ã™
 * - ç›®çš„ã¯â€œä¼šè©±ã‚’è‡ªç„¶ã«ã™ã‚‹â€ã§ã‚ã‚Šã€ã‚¹ãƒˆãƒ¼ãƒªãƒ¼è£œå®Œã§ã¯ãªã„
 */
