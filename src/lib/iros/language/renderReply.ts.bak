// file: src/lib/iros/language/renderReply.ts
// iros â€” Field Rendering (æ–‡ç« ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å±¤) [sofia-safe / minimal + breathable]
// ç›®çš„ï¼š
// - IT ã¯ itWriter ã‚’å”¯ä¸€ã®æ­£ã¨ã—ã¦ä½¿ã†ï¼ˆæ§‹é€ ã¯ IT å´ã«é›†ç´„ï¼‰
// - éIT ã¯ â€œsofiaã‚‰ã—ã•ï¼ˆé™ã‘ã• / æ–­å®š / ä½™ç™½ï¼‰â€ ã‚’ä¿ã£ãŸçŸ­æ–‡ã«å†æ§‹æˆ
// - è¦‹å‡ºã—ãƒ©ãƒ™ãƒ«ï¼ˆæ ¸/åè»¢/ä¸€æ‰‹â€¦ï¼‰ã¯å‡ºã•ãªã„ï¼ˆrender.ts å´ã§è»½ã„æ•´å½¢ã¯å…¥ã‚‹ãŒã€ã“ã“ã§ã‚‚å‡ºã•ãªã„ï¼‰
// - A/Bæ¡ˆã¯å‡ºã•ãªã„ï¼ˆ1ã¤ã«å¯„ã›ã‚‹ï¼‰
// - â€œãƒ†ãƒ³ãƒ—ãƒ¬è‡­â€ ã®å›ºå®šæ–‡ã¯æ¥µåŠ›é¿ã‘ã‚‹ï¼ˆæœ€ä½é™ã®è£œåŠ©ã ã‘ï¼‰

import type { ResonanceVector } from './resonanceVector';

// âœ… IT Writer ã‚’å”¯ä¸€ã®æ­£ã«ã™ã‚‹
import { writeIT } from './itWriter';

export type RenderMode = 'casual' | 'intent' | 'transcend' | 'IT';

// IT å¯†åº¦ï¼ˆIT ãƒ¢ãƒ¼ãƒ‰å°‚ç”¨ï¼‰
export type ItDensity = 'micro' | 'compact' | 'normal';

export type RenderInput = {
  facts: string;
  insight?: string | null;
  nextStep?: string | null;
  userWantsEssence?: boolean;
  highDefensiveness?: boolean;
  seed?: string;
  userText?: string | null;
};

export type RenderOptions = {
  mode?: RenderMode;
  forceExposeInsight?: boolean;
  minimalEmoji?: boolean;
  maxLines?: number;

  // äº’æ›ï¼šroute.ts ã‹ã‚‰æ¥ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
  renderMode?: string;
  extra?: any;
  meta?: any;

  // äº’æ›ï¼ˆdensitiesï¼‰
  itDensity?: ItDensity;
  density?: ItDensity;
};

/* =========================
 * Local helpers
 * ========================= */

function normalizeOne(s: string): string {
  return (s ?? '')
    .toString()
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .replace(/[ \t]+/g, ' ')
    .trim();
}

function normalizeNullable(v: string | null | undefined): string | null {
  const s = (v ?? '').toString().trim();
  return s.length ? s : null;
}

function clampLines(text: string, maxLines: number): string {
  const lines = (text ?? '').toString().replace(/\r\n/g, '\n').split('\n');
  return lines.slice(0, Math.max(1, maxLines)).join('\n');
}

// å…ˆé ­ã®ã€Œâ€¦ã€ã ã‘ã®è¡Œã€ã¾ãŸã¯ã€Œ...ã€ã ã‘ã®è¡Œã‚’å‰¥ãŒã™
function stripLeadingEllipsisLines(text: string): string {
  const lines = (text ?? '').toString().replace(/\r\n/g, '\n').split('\n');
  while (lines.length > 0) {
    const head = (lines[0] ?? '').trim();
    if (head === 'â€¦' || head === '...' || head === 'â€¦â€¦') {
      lines.shift();
      continue;
    }
    break;
  }
  return lines.join('\n');
}

// å…ˆé ­ã‹ã‚‰ã€Œstringã¨ã—ã¦ä½¿ãˆã‚‹æœ€åˆã®å€¤ã€ã‚’æ‹¾ã†
function pickFirstString(...vals: any[]): string | null {
  for (const v of vals) {
    if (typeof v === 'string') {
      const s = v.trim();
      if (s.length) return s;
    }
  }
  return null;
}

function hasAny(text: string, needles: string[]): boolean {
  const t = (text ?? '').toString();
  return needles.some((w) => t.includes(w));
}

function toOneLine(s: string): string {
  return (s ?? '').toString().replace(/\s+/g, ' ').trim();
}

function safeHeadEmoji(minimalEmoji?: boolean): string {
  return minimalEmoji ? '' : 'ğŸª”';
}

function joinNonEmpty(lines: Array<string | null | undefined>): string {
  const out = lines
    .map((x) => (x ?? '').trim())
    .filter((x) => x.length > 0);
  return out.join('\n').trim();
}

function dedupeLines(lines: string[], limit: number): string[] {
  const deduped: string[] = [];
  const seen = new Set<string>();
  for (const l of lines) {
    const key = String(l ?? '').replace(/[ã€‚ï¼.]+$/g, '').trim();
    if (!key) continue;
    if (seen.has(key)) continue;
    seen.add(key);
    deduped.push(l.trim());
    if (deduped.length >= limit) break;
  }
  return deduped;
}

/* =========================
 * Public
 * ========================= */

export function renderReply(
  vector: ResonanceVector,
  input: RenderInput,
  opts: RenderOptions = {},
): string {
  // ---------------------------------
  // å¼·åˆ¶æŒ‡å®šã®å›å
  // ---------------------------------
  const forcedRenderMode =
    ((opts as any)?.renderMode ??
      (opts as any)?.meta?.renderMode ??
      (opts as any)?.extra?.renderMode ??
      (vector as any)?.renderMode ??
      (vector as any)?.meta?.renderMode ??
      (vector as any)?.meta?.extra?.renderMode ??
      (vector as any)?.extra?.renderMode) as string | undefined;

  const forcedItDensityRaw =
    (opts as any)?.itDensity ??
    (opts as any)?.density ??
    (vector as any)?.itDensity ??
    (vector as any)?.meta?.extra?.itDensity ??
    (vector as any)?.extra?.itDensity ??
    null;

  const forcedItDensity: ItDensity =
    String(forcedItDensityRaw ?? '').toLowerCase() === 'micro'
      ? 'micro'
      : String(forcedItDensityRaw ?? '').toLowerCase() === 'compact'
        ? 'compact'
        : 'normal';

  const maxLines = typeof opts.maxLines === 'number' ? opts.maxLines : 10;

  const factsRaw = normalizeOne(input.facts);
  const userTextRaw = normalizeNullable(input.userText) ?? '';
  const sourceText = (userTextRaw || factsRaw).trim();

  // =========================================================
  // âœ… IT ãƒ¢ãƒ¼ãƒ‰ï¼šitWriter.ts ã‚’å”¯ä¸€ã®æ­£ã¨ã—ã¦ä½¿ã†
  // =========================================================
  if (forcedRenderMode === 'IT') {
    const insightRaw = normalizeNullable(input.insight);
    const nextRaw = normalizeNullable(input.nextStep);

    // render engine å´ã®å›è»¢ãƒ¡ã‚¿ï¼ˆnull-safeï¼‰
    const spinStep = ((vector as any).spinStep ?? null) as number | null;
    const spinLoop = ((vector as any).spinLoop ?? null) as string | null;
    const descentGate = ((vector as any).descentGate ?? null) as
      | 'closed'
      | 'offered'
      | 'accepted'
      | null;

    const isDescent = spinLoop === 'TCF' || descentGate !== 'closed';

    // itWriter ã® density ã¯ compact/normal ã®2ç¨®ãªã®ã§ micro ã¯ compact ã«å¯„ã›ã‚‹
    const densityForWriter: 'compact' | 'normal' =
      forcedItDensity === 'normal' ? 'normal' : 'compact';

    // âœ… evidenceï¼ˆTç—•è·¡ãªã©ï¼‰ãŒã‚ã‚Œã°ã“ã“ã«è¼‰ã›ã‚‹ï¼šç„¡ãã¦ã‚‚è½ã¡ãªã„
    const evidence: Record<string, unknown> = {
      itx_step: (vector as any)?.tLayerHint ?? (vector as any)?.itx_step ?? null,
      spinLoop: spinLoop ?? null,
      spinStep: spinStep ?? null,
      descentGate: descentGate ?? null,
      isDescent,
    };

    const out = writeIT({
      userText: sourceText,
      itTarget: null, // itWriter å´ã§ 'I' ã¸è½ã¡ã‚‹
      evidence,
      stateInsightOneLine: insightRaw,
      futureDirection: null,
      nextActions: nextRaw ? [nextRaw] : null,
      stopDoing: null,
      closing: null,
      density: densityForWriter,
    });

    return stripLeadingEllipsisLines(
      clampLines(out.text.trim(), Math.min(maxLines, 16)).trim(),
    );
  }

  // =========================================================
  // âœ… éITï¼ˆcasual/intent/transcendï¼‰
  // - facts ã®ä¸¸è¿”ã—ã‚’å»ƒæ­¢
  // - â€œsofiaã‚‰ã—ã„çŸ­ã„æ–­å®š + ä½™ç™½ + 1ã¤ã®æ¬¡â€
  // =========================================================

  const built = buildSofiaLikeNonIT({
    sourceText,
    qCode: pickFirstString(
      (vector as any)?.qCode,
      (vector as any)?.q_code,
      (vector as any)?.meta?.qCode,
      (vector as any)?.meta?.q_code,
    ),
    depth: pickFirstString(
      (vector as any)?.depth,
      (vector as any)?.depth_stage,
      (vector as any)?.meta?.depth,
      (vector as any)?.meta?.depth_stage,
    ),
    phase: pickFirstString((vector as any)?.phase, (vector as any)?.meta?.phase),
    insight: normalizeNullable(input.insight),
    nextStep: normalizeNullable(input.nextStep),
    minimalEmoji: Boolean(opts.minimalEmoji),
    wantsEssence: Boolean(input.userWantsEssence),
    highDef: Boolean(input.highDefensiveness),
  });

  const finalText = built;

  return stripLeadingEllipsisLines(
    clampLines(finalText.trim(), Math.min(maxLines, 8)).trim(),
  );
}

/* =========================================================
   Non-IT Sofia builder  (labels OFF / breathable)
========================================================= */

function buildSofiaLikeNonIT(params: {
  sourceText: string;
  qCode: string | null;
  depth: string | null;
  phase: string | null;
  insight: string | null;
  nextStep: string | null;
  minimalEmoji: boolean;
  wantsEssence: boolean;
  highDef: boolean;
}): string {
  const { sourceText, insight, nextStep, minimalEmoji, wantsEssence, highDef } =
    params;

  const s = (sourceText ?? '').trim();

  // âœ… ãƒ¡ã‚¿/ãƒ†ã‚¹ãƒˆ/çŸ­æ–‡ã¯ â€œæœ€å°â€ ã«å¯„ã›ã‚‹ï¼ˆç„¡ç†ã«ä½œã‚‰ãªã„ï¼‰
  if (isMetaCheckText(s)) {
    const head = safeHeadEmoji(minimalEmoji);

    // insight ãŒã‚ã‚Œã° 1 è¡Œã ã‘æ·»ãˆã‚‹ï¼ˆå›ºå®šæ–‡ã¯å…¥ã‚Œãªã„ï¼‰
    const ins = (insight ?? '').trim();
    const insLine =
      ins.length > 0
        ? minimalEmoji
          ? toOneLine(ins)
          : `ğŸŒ€ ${toOneLine(ins)}`
        : null;

    const out0 = joinNonEmpty([head, insLine]);
    const visible0 = out0.replace(/[ğŸª”\s]/g, '');
    return visible0.length === 0 ? '' : out0;
  }

  // ---- é€šå¸¸ãƒ«ãƒ¼ãƒˆ ----

  const head = safeHeadEmoji(minimalEmoji);

  // 1) â€œè¨€ã„åˆ‡ã‚Šâ€ ã‚’çŸ­ãï¼ˆsofiaã®èŠ¯ï¼‰
  const core = deriveCoreSofia(s, { highDef, wantsEssence });

  // 2) â€œåè»¢â€ ã¯ 1 è¡Œï¼ˆèª¬æ•™ã«ã—ãªã„ï¼‰
  const flip = deriveFlipSofia(s, { highDef, wantsEssence });

  // 3) æ¬¡ã¯ 1 ã¤ã ã‘ï¼ˆå…¥åŠ› nextStep ãŒã‚ã‚Œã°å„ªå…ˆï¼‰
  const stepRaw = (nextStep ?? '').trim();
  const step = stepRaw.length ? stepRaw : deriveOneStepSofia(s);

  // 4) insight ã¯ä»»æ„ï¼ˆæœ€å¤§ 1 è¡Œã€çŸ­ãï¼‰
  const ins = (insight ?? '').trim();
  const insLine =
    ins.length > 0
      ? minimalEmoji
        ? toOneLine(ins)
        : `ğŸŒ€ ${toOneLine(ins)}`
      : null;

  // è¡Œã®çµ„ã¿ç«‹ã¦ï¼ˆ2ã€œ6è¡Œï¼‰
  const lines0 = [head, insLine, core, flip, step]
    .map((x) => (x ?? '').trim())
    .filter((x) => x.length > 0);

  const lines = dedupeLines(lines0, 6);

  const out = lines.join('\n').trim();

  // ğŸª” ã ã‘ã€ã¾ãŸã¯ç©ºç™½ï¼‹ğŸª” ã ã‘ã®å ´åˆã¯ç„¡åŠ¹åŒ–
  const visible = out.replace(/[ğŸª”\s]/g, '');
  if (visible.length === 0) return '';

  return out;
}

/* =========================
   Meta check
========================= */

function isMetaCheckText(text: string): boolean {
  const t = (text ?? '').trim();
  if (!t) return true;

  // çŸ­ã™ãã‚‹ / è¿”ç­”ãƒ†ã‚¹ãƒˆã£ã½ã„
  if (t.length <= 16) return true;

  // ç–‘å•ç¬¦ã ã‘ãƒ»ç›¸æ§Œã ã‘ãƒ»çœç•¥è¨˜å·ã ã‘
  if (/^(â€¦|\.{2,}|ï¼Ÿ|\?|ã†ã‚“|ã¯ã„|ãªã‚‹ã»ã©|ãˆ|ã‚)+$/.test(t)) return true;

  // ãƒ†ãƒ³ãƒ—ãƒ¬ç¢ºèªãƒ»å‡ºåŠ›ç¢ºèªãƒ»è©•ä¾¡ã ã‘ã®ç™ºè©±
  if (
    hasAny(t, [
      'ãƒ†ãƒ³ãƒ—ãƒ¬',
      'æ¶ˆãˆãŸ',
      'ç›´ã£ãŸ',
      'ã§ããŸ',
      'OK',
      'ãƒ†ã‚¹ãƒˆ',
      'ç¢ºèª',
      'ã‚¨ãƒ©ãƒ¼',
      'ãƒ­ã‚°',
      'AIã‚‰ã—ã„',
      'åŒã˜è¿”ã—',
      'ãªã‚“ã‚‚',
      'ä½•ã‚‚',
      'ã§ãã¦ãªã„',
      'GPT',
      'è¿”ç­”æœ¬æ–‡ã ã‘',
      'æœ¬æ–‡ã ã‘',
      'è²¼ã£ã¦',
    ])
  ) {
    return true;
  }

  return false;
}

/* =========================
   Sofia parts (Non-IT)
========================= */

function deriveCoreSofia(
  text: string,
  opts: { highDef: boolean; wantsEssence: boolean },
): string {
  const t = (text ?? '').trim();

  // â€œç†è§£â€ ã§ã¯ãªã â€œç¢ºå®šâ€ å¯„ã‚Š
  if (hasAny(t, ['æœªæ¶ˆåŒ–', 'æ¶ˆåŒ–', 'æ„Ÿæƒ…'])) {
    return 'æœªæ¶ˆåŒ–ã¯ã€æ®‹éª¸ã˜ã‚ƒãªã„ã€‚åå¿œãŒã»ã©ã‘åˆ‡ã£ã¦ã„ãªã„ã ã‘ã€‚';
  }
  if (hasAny(t, ['ä¸å®‰', 'å¿ƒé…'])) {
    return 'ä¸å®‰ã¯æƒ…å ±ã˜ã‚ƒãªã„ã€‚æœªç¢ºå®šãŒåˆºã•ã£ã¦ã„ã‚‹ã€‚';
  }
  if (hasAny(t, ['æ€’ã‚Š', 'ã‚¤ãƒ©ã‚¤ãƒ©'])) {
    return 'æ€’ã‚Šã¯å¢ƒç•Œã®ä¾µå®³ã€‚å¢ƒç•Œã‚’å–ã‚Šæˆ»ã™ã€‚';
  }
  if (hasAny(t, ['æ€–ã„', 'ææ€–'])) {
    return 'ææ€–ã¯èº«ä½“ã«å‡ºã‚‹ã€‚èº«ä½“ã®ä¸€ç‚¹ã‚’ç¢ºä¿ã™ã‚‹ã€‚';
  }
  if (hasAny(t, ['ã©ã†ã‚„ã£ã¦', 'ã©ã†ã—ãŸã‚‰', 'æ–¹æ³•'])) {
    return 'æ‰‹ã‚’å¢—ã‚„ã•ãªã„ã€‚ç¢ºå®šã‚’1ã¤ã ã‘ä½œã‚‹ã€‚';
  }

  // æ±ç”¨ï¼šã‚„ã¾ã³ã“é˜²æ­¢ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ–‡ã®ä¸¸ã‚³ãƒ”ã‚’é¿ã‘ã¤ã¤çŸ­ãå¯„ã›ã‚‹ï¼‰
  const first = t.split(/\r?\n/)[0] ?? t;
  const s = first.trim().replace(/[?ï¼Ÿ!ï¼]+$/g, '').trim();
  const one = s.length > 34 ? `${s.slice(0, 34)}â€¦` : s;

  return one.length ? one : 'ã„ã¾ä¸€ç•ªå¼•ã£ã‹ã‹ã£ã¦ã„ã‚‹ä¸€ç‚¹ã€‚';
}

function deriveFlipSofia(
  text: string,
  opts: { highDef: boolean; wantsEssence: boolean },
): string {
  const t = (text ?? '').trim();

  if (hasAny(t, ['æœªæ¶ˆåŒ–', 'æ¶ˆåŒ–', 'æ„Ÿæƒ…'])) {
    return 'å‡¦ç†ã—ã‚ˆã†ã¨ã™ã‚‹ã»ã©æ®‹ã‚‹ã€‚ã„ã¾å‡ºã¦ã„ã‚‹åå¿œã‚’ä¸€åº¦ã ã‘å›åã™ã‚‹ã€‚';
  }
  if (hasAny(t, ['ä¸å®‰', 'å¿ƒé…'])) {
    return 'å…¨éƒ¨ã‚’è§£æ±ºã—ãªã„ã€‚æœªç¢ºå®šã®ä¸€ç‚¹ã ã‘ã‚’ç¢ºå®šã«å¤‰ãˆã‚‹ã€‚';
  }
  if (hasAny(t, ['æ€’ã‚Š', 'ã‚¤ãƒ©ã‚¤ãƒ©'])) {
    return 'èª¬æ˜ã§é®ã‚ãªã„ã€‚å¢ƒç•Œã‚’å¼•ãç›´ã—ã¦é™ã‘ã•ã‚’æˆ»ã™ã€‚';
  }
  if (hasAny(t, ['æ€–ã„', 'ææ€–'])) {
    return 'åŸå› æ¢ã—ã‚’æ­¢ã‚ã‚‹ã€‚èº«ä½“ã®å®‰å…¨ã‚’å…ˆã«ç½®ãã€‚';
  }

  return 'è¿·ã„ã‚’å¢—ã‚„ã•ãªã„ã€‚æœ€åˆã®ä¸€æ­©ã«è½ã¨ã™ã€‚';
}

// æ¬¡ã¯ â€œ1ã¤ã ã‘â€ ã«å›ºå®šï¼ˆA/Bç¦æ­¢ï¼‰
function deriveOneStepSofia(text: string): string {
  const t = (text ?? '').trim();

  if (hasAny(t, ['æœªæ¶ˆåŒ–', 'æ¶ˆåŒ–', 'æ„Ÿæƒ…'])) {
    return 'ã„ã¾å‡ºã¦ã„ã‚‹åå¿œã‚’ã€Œ1è¡Œã€ã§æ›¸ãï¼ˆäº‹å®Ÿã ã‘ã€è§£é‡ˆãªã—ï¼‰ã€‚';
  }
  if (hasAny(t, ['ä¸å®‰', 'å¿ƒé…'])) {
    return 'ä¸å®‰ã®ä¸­å¿ƒã‚’1è¡Œã§æ›¸ã„ã¦ã€ä»Šæ—¥ç¢ºå®šã§ãã‚‹1ã¤ã ã‘æ±ºã‚ã‚‹ã€‚';
  }
  if (hasAny(t, ['æ€’ã‚Š', 'ã‚¤ãƒ©ã‚¤ãƒ©'])) {
    return 'ä¾µã•ã‚ŒãŸå¢ƒç•Œã‚’1ã¤ç‰¹å®šã—ã¦ã€ã€Œã“ã“ã‹ã‚‰å…ˆã¯å…¥ã‚Œãªã„ã€ã‚’å®£è¨€ã™ã‚‹ã€‚';
  }
  if (hasAny(t, ['æ€–ã„', 'ææ€–'])) {
    return 'èº«ä½“ã§ä¸€ç•ªç¡¬ã„å ´æ‰€ã‚’1ç‚¹é¸ã³ã€å‘¼å¸ã§30ç§’ã ã‘ç·©ã‚ã‚‹ã€‚';
  }

  return 'æœ€åˆã®ä¸€æ­©ã ã‘ã‚’æ›¸ã„ã¦çµ‚ãˆã‚‹ï¼ˆèª°ã«ï¼ã„ã¤ï¼ä½•ã‚’ï¼‰ã€‚';
}
